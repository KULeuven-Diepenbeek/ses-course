[
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/versiebeheer/",
	"title": "1. Versie- en issuebeheer",
	"tags": [],
	"description": "",
	"content": "  Wat is de beste manier om source code te bewaren?\n Wat is versiebeheer of source control? Source Control is een sleutelbegrip voor ontwikkelteams. Het stelt iedereen in staat om aan dezelfde source file te werken zonder bestanden op- en neer te sturen, voorziet backups, maakt het mogelijk om releases en branches uit te rollen, \u0026hellip;\nEen versiebeheer systeem bewaart alle wijzigingen aan (tekst)bestanden. Dat betekent dat eender welke wijziging, door wie dan ook, teruggedraaid kan worden. Zonder versiebeheer is het onmogelijk om code op één centrale plaats te bewaren als er met meerdere personen aan wordt gewerkt. Zelfs met maar één persoon is het toch nog steeds sterk aan te raden om te werken met versionering. Fouten worden immers snel gemaakt. Een bewaarde wijziging aan een bestand is permanent op je lokale harde schijf: de volgende dag kan je niet het origineel terug boven halen. Er wordt samen met delta\u0026rsquo;s ook veel metadata bewaard (tijdstippen, commit comments, gebruikers, bestandsgroottes, \u0026hellip;)\nZie links onderaan voor meer informatie.\nWaarom versioneren? Dat verduidelijkt Geek \u0026amp; Poke:\n   Zonder versionering stuurt iedereen e-mail attachments door naar elkaar, in de verwachting een aangepaste versie terug te ontvangen. Maar, wat gebeurt er met:\n Conflicten? (iemand wijzigt iets in dezelfde cel als jij) Meerdere bestanden? (je ontvangt verschillende versies, welke is nu relevant?) Nieuwe bestanden? (je ontvangt aparte bestanden met nieuwe tabbladen) Bestandstypes? (iemand mailt een .xslx, iemand anders een .xls) \u0026hellip;  Het wordt al snel duidelijk dat het delen van celdata beter wordt overgelaten aan Google Sheets, waar verschillende mensen tegelijkertijd gegevens in kunnen plaatsen. Hetzelfde geldt voor source code: dit wordt beter overgelaten aan een versiebeheer systeem.\nIn de praktijk: Git Git is een gedecentraliseerd versiebeheer systeem waarbij de hele repository inclusief historiek lokaal wordt geplaatst zodra een clone commando wordt uitgevoerd. Oudere gecentraliseerde systemen zoals SVN en CVS bewaren (meta-)data op één centrale plaats: de version control server. Voor dit vak wordt resoluut voor git gekozen.\nOnderstaande Figuur geeft het verschil weer tussen een gecentraliseerd versioneringssysteem, zoals SVN, CVS en MS SourceSafe, en een gedecentraliseerd systeem, zoals Git. Elke gebuiker heeft een kopie van de volledige repository op zijn lokale harde schijf staan. Bij SVN communiceren \u0026lsquo;working copies\u0026rsquo; met de server. Bij Git communiceren repositories (inclusief volledige history) met eender welke andere repository. \u0026lsquo;Toevallig\u0026rsquo; is dat meestal een centrale server, zoals Github.com, Gitlab.com of BitBucket.com.\n  SVN VS Git  (Image Src)\nVanaf nu wordt verondersteld dat labo oefeningen gecommit worden in git op Github.com: een zeer populair open source software ontwikkelingsplatform dat gebruiksvriendelijk is. Andere populaire platformen zijn Gitlab, Codeberg, Gitea (self-hosted), \u0026hellip; Deze software platformen voorzien een extra laag bovenop Git (de web UI) die het makkelijk maakt op via knoppen acties uit te voeren. Het voegt ook een social media esque aspect toe: comments, requests, issues, \u0026hellip;\nWat is de beste manier om vanaf nul te leren werken met Git?\n git - the simple guide; en daarna: Het Pro Git handboek.  SVN, RCS, MS SourceSafe, CVS, \u0026hellip; zijn allemaal version control systemen (VCS). Merk op dat Git géén klassieke \u0026ldquo;version control\u0026rdquo; is maar eerder een collaboratieve tool om met meerdere personen tegelijkertijd aan verschillende versies van een project te werken. Er is geen revisienummer dat op elkaar volgt zoals in CVS of SVN (v1, v2, v3, v'), en er is geen logische timestamp. (Zie git is not revision control). Ook, in tegenstelling tot bovenstaande tools, kan je Git ook compleet lokaal gebruiken, zonder ooit te pushen naar een upstream server. Het is dus \u0026ldquo;self-sufficient\u0026rdquo;: er is geen \u0026ldquo;server\u0026rdquo; nodig: dat is je PC zelf.\n De Git workflow Een typische workflow is als volgt:\n git clone [url]: Maakt een lokale repository aan die je op Github hebt gecreëerd. Het commando maakt een subdirectory aan. Doe je programmeerwerk. git status en git diff: Bekijk lokale changes voordat ze naar de server gaan. git add [.]: Geef aan welke changes staged worden voor commit git commit -m [comment]: commit naar je lokale repository. Wijzingen moeten nu nog naar de Github server worden gesynchroniseerd. git push: push lokale commits naar de Github server. Vanaf nu kan eender wie die meewerkt aan deze repository de wijzigingen downloaden op zijn lokaal systeem. git pull: pull remote changes naar je lokale repository. Wijzigingen moeten altijd eerst gepushed worden voordat iemand anders kan pullen.  De output van git status ziet er zo uit:\n Wouters-MacBook-Air:brainbaking wgroenev$ git status On branch master Your branch is up-to-date with 'origin/master'. Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: content/teaching/cpp/labo-1.md modified: content/teaching/cpp/labo-2.md modified: content/teaching/cpp/labo-3.md modified: content/teaching/cpp/labo-4.md modified: content/teaching/cpp/labo-5.md modified: content/teaching/cpp/labo-6.md deleted: docs/CNAME deleted: docs/essays/i-am-jealous-of-my-dog/index.html  De output van git diff ziet er zo uit:\n Wouters-MacBook-Air:brainbaking wgroenev$ git diff diff --git a/content/teaching/cpp/labo-1.md b/content/teaching/cpp/labo-1.md index 654a4f6..11f0597 100644 --- a/content/teaching/cpp/labo-1.md +++ b/content/teaching/cpp/labo-1.md @@ -4,7 +4,7 @@ disableComments: true ---  Waarbij de +++ regels wijzigingen zijn die zijn toegevoegd, en --- die zijn verwijderd. Zowel bestanden als regels binnen bestanden zijn zichtbaar in de difference tool.\nConflicten oplossen Lees eerst hoofdstuk 2 van het Pro Git boek.\nBranches Lees eerst hoofdstuk 3 van het Pro Git boek.\nHoofdstuk 1 t.e.m. 3 van het bovenstaande Pro Git boek horen bij de leerstof!\n Een branch aanmaken kan via het git branch commando. Dit geeft een overzicht van beschikbare branches, en met een argument maak je een nieuwe aan. git checkout laat je switchen naar die branch. Het * symbool duidt de actieve branch aan. Hieronder wordt een nieuwe branch genaamd bugfixbranch aangemaakt nadat git toont dat er geen branches zijn. Daarna wordt er naar die branch overgeschakeld:\n Wouters-Air:sessylibrary wgroeneveld$ git branch * master Wouters-Air:sessylibrary wgroeneveld$ git branch bugfixbranch Wouters-Air:sessylibrary wgroeneveld$ git branch bugfixbranch * master Wouters-Air:sessylibrary wgroeneveld$ git checkout bugfixbranch Switched to branch 'bugfixbranch' Wouters-Air:sessylibrary wgroeneveld$ git branch * bugfixbranch master  Merk op dat eerst branchen en dan die branch uitchecken sneller gaat met bit checkout -b\u0026mdash;enkel als die branch not niet bestaat.\nEen branch lokaal committen kan altijd, maar een push kan de volgende fout geven: fatal: The current branch bugfixbranch has no upstream branch. In dat geval dien je de branch \u0026lsquo;upstream\u0026rsquo; te pushen naar de Github server door middel van git push --set-upstream origin bugfixbranch.\nNa een branch commit is de volgende knop zichtbaar op Github:\n   De Compare \u0026amp; Pull Request knop maakt het mogelijk om wijzigingen op de bugfixbranch tot op de master branch te brengen. Dit kan ook via het commando git merge bugfixbranch in de master branch. Een demo toont dit aan. Daarna hebben we de branch niet meer nodig: git branch -d bugfixbranch. Merk op dat dit enkel lokaal de kopie van de branch verwijderd. De remote, op Github.com, verwijderen, vereist meer werk: git push origin --delete bugfixbranch.\nGeen idee wat de mogelijke opties zijn van een bepaald subcommando? Gebruik git help [cmd], bijvoorbeeld git help branch.\n Ik zie niet alle branches, hoe komt dat? Een git pull commando zal soms in de console \u0026lsquo;new branch [branchnaam]\u0026rsquo; afdrukken, maar toch zal je deze niet tot je beschikking hebben met het git branch commando. Dat komt omdat branches dan ook nog (lokaal) getracked moeten worden:\n Controleer welke branch je lokaal wilt volgen met git branch -r Selecteer een bepaalde branch, waarschijnlijk origin/[naam] Track die branch lokaal met git branch --track [naam] origin/[naam] Vanaf nu kan je ook switchen naar die branch, controleer met git branch  Merk op dat een branch verwijderen met git branch -d enkel gaat bij lokale branches. Een remote branch verwijderen wordt niet met het branch subcommando gedaan, maar met git push origin --delete [branch1] [branch2] ....\nBug tracking met Github Enkele \u0026lsquo;kleine probleempjes\u0026rsquo; in software worden al snel een hele berg aan grote problemen als er niet op tijd iets aan wordt gedaan. Bedrijven beheren deze problemen (issues) met een bug tracking systeem, waar alle door klant of collega gemeldde fouten van het systeem in worden gelogd en opgevolgd. Op die manier kan een ontwikkelaar op zoek naar werk in deze lijst de hoge prioritaire problemen identificeren, oplossen, en terug koppelen naar de melder.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; Bug[Bug discovery] Report[Bug report] Backlog[Bug in backlog met issues] Prio[Bug in behandeling] Fix[Bug fixed] Bug -- Report Report -- Backlog Backlog -- Prio Prio -- Fix  De inhoud van deze stappen hangt af van bedrijf tot bedrijf, maar het skelet blijft hetzelfde. Bugs worden typisch gereproduceerd door middel van unit testen op een bepaalde git branch om de bestaande ontwikkeling van nieuwe features niet in de weg te lopen. Wanneer het probleem is opgelost, wordt deze branch gemerged met de master branch:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; masterx[Master branch x] mastery[Master branch y] bugbranch[Create bug branch] bugfix[Bugfix on branch] masterx -- mastery masterx -- bugbranch bugbranch -- bugfix bugfix -- mastery  Github Issues is een minimalistische feature van Github die het mogelijk maakt om zulke bugs op te volgen. Een nieuw issue openen en een beschrijving van het probleem meegeven (samen met stappen om het te reproduceren), maakt een nieuw item aan dat standaard op \u0026lsquo;open\u0026rsquo; staat. Dit kan worden toegewezen aan personen, en daarna worden \u0026lsquo;closed\u0026rsquo;, om aan te geven dat ofwel het probleem is opgelost, ofwel het geen echt probleem was. Issues kunnen worden gecategoriseerd door middel van labels.\nLabo oefeningen Opgave 1 Maak een Github.com account aan, als je dat nog niet hebt. Download de commandline tools https://git-scm.com/downloads, de officiele distributie, multiplatform, en probeer voor opgave twee de repository \u0026lsquo;ses-issue-sandbox\u0026rsquo; te clonen: git clone https://github.com/KULeuven-Diepenbeek/ses-issue-sandbox.git.\nVoor 2ba studenten (NIET schakelstudenten): Gebruik https://github.com/KULeuven-Diepenbeek/ses-issue-sandbox2 (nummber 2).\n Gebruik het Pro Git boek om kennis te maken met basis commando\u0026rsquo;s van git. Het is de bedoeling om de commandline tools te leren kennen, en niet om met Github Desktop te werken.\nOpgave 2 Kinderen vermaken zichzelf met een dagje aan zee. Het strand verdient extra veel aandacht, maar niet alle kinderen zijn blijkbaar even tevreden met onze implementatie. Kijk naar de issue lijst van de repository om te kijken wat de wensen zijn van onze gebruikers.\nKies er eentje uit om op te lossen - het maakt niet uit welke. Los elke issue op in een aparte branch! De oplossing bestaat uit twee fases:\n Implementeer de interface Playable door een nieuwe klasse te maken van het object waar het kind mee wenst te spelen aan zee (zie issue). Maak een nieuwe instantie aan van dit object in SandboxMain.  Neem een kijkje bij de voorbeeld implementaties SandCastle en BucketOfWater.\nMerk op dat je onvoldoende push rechten hebt om lokale wijzigingen aan de repository te uploaden naar de Github server. We geven je nu de status van \u0026lsquo;collaborator\u0026rsquo;, zodat iedereen gemachtigd is om wijzigingen door te voeren.\nDenkvragen  In welk geval is het aanmaken van een branch een goed idee, in plaats van verder te werken op de (enige) master branch? Lees eerst het Pro Git boek hoofdstuk over branches. In welk geval is het pushen van wijzigingen vanuit een branch naar de master branch een goed idee? Wanneer niet?  Extra leermateriaal  Pro Git handboek, hoofdstuk 1 tot en met 3. git - the simple guide Code Forest: Git VS SVN the Harvard.edu guide to Git  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/dependency-management/",
	"title": "2. Dependency Management",
	"tags": [],
	"description": "",
	"content": "Lees ook: Meer uitleg over de Gradle build tool.\n  Wat is de beste manier om afhankelijkheden te beheren?\n Wat is een \u0026lsquo;dependency\u0026rsquo;? Een dependency, of afhankelijkheid, is een externe bibliotheek die wordt gebruikt tijdens de ontwikkeling van een toepassing. Tijdens het vak \u0026lsquo;Software ontwerp in Java\u0026rsquo; zijn reeds de volgende externe libraries gebruikt:\n JavaFX Google Gson JUnit  Het vertrouwen op zo\u0026rsquo;n library houdt in dat een extern bestand, zoals een .jar of .war bestand, download en koppelt wordt aan de applicatie. In Java koppelen we externe libraries door middel van het CLASSPATH: een folder die de compiler gebruikt om te zoeken naar klassen.\nSerialisatie met behulp van Gson kan op deze manier:\nfun main(args: Array\u0026lt;String\u0026gt;) { val gson = Gson() println(gson.toJson(1)) } public class Main { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(1)); } }  Bovenstaande Main.java compileren zonder meer geeft de volgende fout:\n Wouters-MacBook-Air:java wgroeneveld$ javac Main.java Main.java:3: error: cannot find symbol Gson gson = new Gson(); ^ symbol: class Gson location: class Main  De klasse Gson is immers iets dat we niet hebben zelfgemaakt, maar wensen te importeren via het import com.google.gson.*; statement. Er is een manier nodig om de gedownloade library te linken met onze bestaande code: javac -cp gson-2.8.6.jar Main.java. Het programma uitvoeren kan met java -cp gson-2.8.6.jar:. Main. Er worden dus 2 zaken aan het classpath meegegeven: de Google jar, en de huidige directory (.), om Main.class terug te vinden.\nJava classpath separators zijn OS-specifiek! Windows: ; in plaats van Unix: :.\n Dit programma kan schematisch worden voorgesteld als volgt:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A[\"Main klasse\"] C[\"Gson 2.8.6\"] A --|dependent on| C  De dependency in bovenstaand voorbeeld is gson-2.8.6.jar. Een gemiddelde Java applicatie heeft echter meer dan 10 dependencies! Het beheren van deze bestanden en de verschillende versies (major, minor, revision) geeft vaak conflicten die beter beheerd kunnen worden door tools dan door de typische vergeetachtigheid van mensen. Dit kluwen aan afhankelijkheden, dat erg snel onhandelbaar kan worden, noemt men een Dependency Hell. Er zijn varianten: DLL Hell sinds 16-bit Windows versies, RPM Hell voor Redhat Linux distributies, en JAR Hell voor Java projecten.\nZie ook xkcd\u0026rsquo;s Tech Loops rommelboeltje:\n   Wie beheert dependencies? De ontwikkelaar (manueel) De eenvoudigste manier om een library te gebruiken is de volgende procedure te volgen:\n Navigeer naar de website van de library en download deze in een bepaalde map, zoals /lib. Importeer de juiste klasses met het import statement. Compileer de code door middel van het -cp dependency1.jar argument.  Voor kleine programma\u0026rsquo;s met enkele libraries is dit meer dan voldoende. Het kost echter redelijk veel moeite om de juiste versie te downloaden: stap 1 kost meestal meer dan 5 minuten werk.\nMerk op dat jar files in een submap steken de syntax van de -cp parameter lichtjes wijzigt: bij compileren wordt het javac -cp lib/* bla.java en bij uitvoeren wordt het java -cp \u0026quot;lib/*:.\u0026quot; bla. Zonder de toegevoegde punt (.) bij het java commando wordt de main methode in bla zelf niet gevonden. Wildcards zijn toegestaan. Zie ook Understanding the Java Classpath. In de praktijk worden build tools als Gradle gebruikt om projecten automatisch te builden, inclusief het doorgeven van de juiste parameters/dependencies.\n De tools (automatisch) Apache Maven Maven is een build tool van de Apache Foundation die zowel de manier waarop de software wordt gecompileerd als zijn afhankelijkheden beheert. Maven is de voorloper van Gradle en bestaat reeds 15 jaar.\nEen Maven project heeft een pom.xml bestand (Project Object Model), waarin in XML formaat wordt beschreven hoe de structuur er uit ziet, welke libraries men gebruikt, en zo voort:\n\u0026lt;project\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; Maven is erg populair in de Java wereld, waardoor er verschillende servers zijn die deze pom bestanden samen met hun libraries beheren, zoals de Central Maven Repository en de Google Maven Repository mirrors. De syntax van het configuratiebestand is echter erg onoverzichtelijk, en er zijn ondertussen betere alternatieven beschikbaar, zoals Gradle.\nGradle Belangrijk: neem dit eerst door - Meer informatie over Gradle.\nGradle is net zoals Maven een automatisatie tool voor de Java wereld (en daarbuiten), die verder bouwt op de populariteit van Maven door bijvoorbeeld compatibel te zijn met de Repository servers, maar de grootste pijnpunten wegneemt: een slorig configuratiebestand in XML, en complexe command-line scripts.\nDe volgende procedure volg je als je Gradle dependencies laat beheren:\n Zoek op de Maven Repository website naar de gewenste library. Voeg één regel toe in je gradle.build bestand, in het dependencies stuk:  dependencies { implementation 'com.google.code.gson:gson:2.8.6' } Bij het uitvoeren van gradlew download Gradle automatisch de juiste opgegeven versie. Gradle bewaart lokale kopies van libraries in een submap van je home folder: ~/.gradle. Dit kan je controleren door in IntelliJ naar File -\u0026gt; Project Structure te gaan en te klikken op \u0026ldquo;Libraries\u0026rdquo;:\n  Het lokale path naar de auto-cached libraries.  Voordelen van het gebruik van deze methode:\n Het zoeken van libraries beperkt zich tot één centrale (Maven Repository) website, waar alle verschillende versie revisies duidelijk worden vermeld. Het downloaden van libraries beperkt zich tot één centrale locatie op je harde schijf: 10 verschillende Java projecten die gebruik maken van Gson vereisen linken naar dezelfde gradle bestanden. Het beheren van dependencies en versies beperkt zich tot één centraal configuratiebestand: build.gradle. Dit is (terecht) een integraal deel van het project!  Lees ook: Declaring dependencies in de Gradle docs.\nCustom Repository URLs voorzien Veelgebruikte libraries zijn eenvoudig te vinden via de Central Maven Repository. Wanneer echter een eigen library werd gecompileerd, die dan in andere projecten worden gebruikt, schiet deze methode tekort: interne libraries zijn uiteraard niet op een publieke server gepubliceerd.\nGradle voorziet gelukkig genoeg een eenvoudige manier om repository websites toe te voegen, met de volgende eenvoudige syntax:\n repositories { mavenCentral() }  mavenCentral(), jcenter(), en google() zijn ingebouwde repositories. Eigen Maven folders en URLs toevoegen kan ook, evenals een lokale folder: \n repositories { maven { // dit kan zowel een folder als HTTP(s) URL zijn url \"/Users/wgroeneveld/development/java/maven-repo\" } flatDir { dirs 'lib' } }  Transitieve dependencies Er zijn twee types van dependencies: directe (1) en transitieve (2). Een directe dependency is een afhankelijkheid die het project nodig heeft, zoals het gebruik van Gson, waarbij dit in de dependencies {} config zit. Een transitieve of indirecte dependency is een dependency van een dependency. In de oefening hieronder maken we een project (1) aan, dat een project (2) gebruikt, dat Gson gebruikt. In project 1 is project 2 een directe dependency, en Gson een transitieve. In Project 2 is Gson een directe dependency (en komt project 1 niet voor):\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A[Project een] B[Project twee] C[Gson] A -- B B -- C A -.- C  Het is geen goed idee om bij fouten in uitvoering de zachte link (stippellijn) te veranderen in een harde, door dit als directe dependency toe te voegen. Gradle biedt hier alternatieven voor. Het voor de hand liggende alternatief is van de library ook een Maven module te maken en deze te uploaden naar een (lokale) repository.\nPubliceren naar een Maven Repository Klik op \u0026lsquo;View All\u0026rsquo; bij de Gson module op de MVN Central Repo om te inspecteren welke bestanden typisch worden aangeleverd in een Maven repository:\n De library zelf, in een bepaalde versie. Eventueel de javadoc en/of sources als aparte jars. Een .pom XML bestand. metadata als md5 checksums.  Het XML bestand beschrijft welke afhankelijkheden deze module op zich heeft. Zo kan een hele dependency tree worden opgebouwd! Het beheren van alle afhankelijkheden is complexer dan op het eerste zicht lijkt, en laat je dus beter over aan deze gespecialiseerde tools. Google heeft voor Gson enkel Junit als test dependency aangeduid:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Grote projecten kunnen makkelijk afhankelijk zijn van tientallen libraries, die op hun beurt weer afhankelijk zijn van libraries. Een typische grote webapplicatie geschreven in java heeft de volgende dependency tree, die opgevraagd kan worden via Gradle of Maven:\n   Gebruik hiervoor de task dependencies: ./gradlew dependencies. Detailinformatie voor specifieke dependencies kunnen worden opgevraagd met de dependencyInsight task. Zie ook: Viewing and debugging dependencies in de Gradle docs.\nGradle voorziet een plugin genaamd \u0026lsquo;maven-publish\u0026rsquo; die deze bestanden automatisch aanmaakt. Activeer de plugin en voeg een publishing tag toe met de volgende properties:\nplugins { java kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;1.6.0\u0026#34; `maven-publish` } publishing { publications { create\u0026lt;MavenPublication\u0026gt;(\u0026#34;maven\u0026#34;) { groupId = \u0026#34;be.kuleuven\u0026#34; artifactId = \u0026#34;projectnaam\u0026#34; version = \u0026#34;1.0-SNAPSHOT\u0026#34; from(components[\u0026#34;java\u0026#34;]) } } repositories { maven { url = uri(layout.buildDirectory.dir(\u0026#34;/Users/wgroeneveld/development/java/maven-repo\u0026#34;)) } } } plugins { id \u0026#39;java\u0026#39; id \u0026#39;maven-publish\u0026#39; // toevoegen! } publishing { publications { maven(MavenPublication) { groupId = project.group.toString() version = version artifactId = \u0026#39;projectnaam\u0026#39; from components.java } } repositories { maven { url = \u0026#34;/Users/wgroeneveld/development/java/maven-repo\u0026#34; } } }  Windows gebruikers dienen in de url value te werken met dubbele backslashes (\\\\) in plaats van forward slashes (/) om naar het juiste pad te navigeren.\nOpgelet met Kotlin-specifieke build files: Als je een build.gradle.kts bestand gebruikt (Gradle in Kotlin-script formaat), is de syntax sterk gewijzigd (klik dan hierboven op de tab \u0026ldquo;Kotlin\u0026rdquo;). Zie ook de officiele Gradle documentatie over how to publish in Maven.\n Deze uitbreiding voegt de target publish toe aan Gradle. Dus: ./gradlew publish publiceert de nodige bestanden in de aangegeven folder. Een Gradle project die daar gebruik van wenst te maken dient enkel een tweede Maven Repository plaats te definiëren:\nrepositories { mavenCentral() maven { url = uri(layout.buildDirectory.dir(\u0026#34;/Users/wgroeneveld/development/java/maven-repo\u0026#34;)) } } repositories { mavenCentral() maven { url = \u0026#34;/Users/wgroeneveld/development/java/maven-repo\u0026#34; } }  Labo oefeningen Neem dit eerst door: Meer informatie over Gradle.\nOpgave 1 Ontwerp een eenvoudige library genaamd \u0026lsquo;scorebord\u0026rsquo; die scores kan bijhouden voor bordspelletjes. Deze library kan kan gebruikt worden door toekomstige digitale Java bordspellen. In een Scorebord kan je spelers toevoegen door middel van een naam en een score. Er is een mogelijkheid om de huidige score van een speler op te vragen, en de winnende speler. Deze gegevens worden met behulp van Gson in een JSON bestand bewaard, zodat bij het heropstarten van een spel de scores behouden blijven. De API (publieke methodes) van de library ziet er zo uit:\ndata class Speler(val naam: String, val score: Int) class Scorebord() { fun voegToe(x: String, huidigeScore: int) { } fun getTotaleScore(x: String): Int { } fun getWinnaar(): String { } } public class Speler { public String getNaam() { } public int getScore() { } } public class Scorebord { public void voegToe(String x, int huidigeScore) { } public int getTotaleScore(String x) { } public String getWinnaar() { } }  De klasse Speler is een intern hulpmiddel om te serialiseren.  Extra methodes toevoegen mag altijd. De constructor van het scorebord leest automatisch de score van de vorige keer in, als dat bestand bestaat. Denk bij de implementatie aan een collectie om spelers en hun scores bij te houden. Maak via IntelliJ een nieuw Gradle - Java project. Groupid: be.kuleuven. Arifactid: scorebord. Vergeet niet op \u0026lsquo;refresh\u0026rsquo; te drukken wanneer je een dependency toevoegt (linksboven op onderstaande screenshot):\n   Met het commando gradlew jar creëer je het bestand scorebord-1.0-SNAPSHOT.jar in de build/libs folder.\nDenk na over het bijhouden van Spelers in Scorebord. Een simpele ArrayList zal volstaan. Gebruik Gson in een methode als save() om gewoon de lijst (of het object zelf) naar de HDD te serialiseren. Tip: java.nio.files.write.\n Tip: indien de Gralde wrapper een oudere versie aanmaakt (\u0026lt; v6), update met gradlew wrapper --gradle-version 6.0.1. Gradle versie 6 of groter is vereist voor JDK 13 of groter.\nOpgave 2 Maak een nieuw Gradle project aan genaamd \u0026lsquo;scorebord-darts\u0026rsquo;, dat bovenstaand scorebord project als een library gaat gebruiken. Bewaar de jar file lokaal in een \u0026lsquo;lib\u0026rsquo; folder en instrueer Gradle zo dat dit als flatDir repository wordt opgenomen (zie boven). Het tweede project heeft als Artifactid scorebord-darts. De klasse DartsGame ziet er zo uit:\nclass DartsGame() { private val player = \u0026#34;jos\u0026#34; fun throwDart() { } } public class DartsGame { private String player = \u0026#34;jos\u0026#34;; public void throwDart() {} }  Als de dependencies goed liggen, kan je een nieuw Scorebord aanmaken, en herkent IntelliJ dit met CTRL+Space:\n   Maak een Main klasse met een public static void main(String[] args) methode, waarin een darts spel wordt opgezet, en een aantal keer ter test wordt \u0026lsquo;gegooid\u0026rsquo;. Druk de totale score en de winnaar af, dat opgevraagd kan worden via het spelbord. Krijg je deze klasse opgestart?\n  Task :Main.main() FAILED Exception in thread \"main\" java.lang.NoClassDefFoundError: com/google/gson/Gson at be.kuleuven.scorebord.Scorebord.(Scorebord.java:24) at be.kuleuven.DartsGame.(DartsGame.java:11) at be.kuleuven.Main.main(Main.java:6) Caused by: java.lang.ClassNotFoundException: com.google.gson.Gson at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ... 3 more Caused by: java.lang.ClassNotFoundException: com.google.gson.Gson Execution failed for task ':Main.main()'.  Process 'command '/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home/bin/java'' finished with non-zero exit value 1  Dit werkt niet omdat we een library gebruiken (ScoreBord), die op zijn beurt een library gebruikt (Gson), die niet in onze huidige Gradle file is gedefiniëerd. Om dit op te lossen dienen we over te schakelen naar een lokale Maven repository, die ook transitieve dependencies automatisch inlaadt. Verwijder de flatDir en voeg een lokale maven URL toe. Publiceer in het scorebord project naar diezelfde URL volgens de instructies van de maven-publish plugin.\nOpgave 3 (extra) Bovenstaande screenshot geeft aan dat IntelliJ methodes herkent van de Scorebord klasse. Er is echter geen javadoc voorzien die uitlegt wat welke parameter doet. Voorzie javadoc bij alle publieke methodes. Dit moet ook mee worden verpakt in het jar bestand, zodat het ander project deze kan herkennen. Probeer uit te zoeken wat je hier voor moet doen in het build.gradle bestand.\nOpgave 4 (extra) Genereer met behulp van Gradle van de SESsy library een dependency tree en inspecteer welke dpendencies transitief zijn en welke direct.\nExtra leermateriaal  Opfriscursus Java nodig? Neem je INF1 cursus er terug bij, of volg een van de talrijke online cursussen, zoals Learn Java van Codeacademy. Concepten zoals packages, structuur, imports, klasses, objecten en instances, containers, \u0026hellip; zijn voor dit vak elementaire basiskennis.  Denkvragen  Hoe zou je transitieve dependencies handmatig kunnen beheren? Wat zijn de voor- en nadelen? Wat gebeurt er als project1-1.0 afhankelijk is van lib1-1.0 en lib1-2.0, en lib1-1.0 van lib2-1.0 - een oudere versie dus? Heb je altijd test dependencies nodig? Wat gebeurt er met een test dependency, libtest-1.0, van lib1-1.0, als project1-1.0 afhankelijk is van lib1-1.0? Als ik publiceer naar een lokale folder, welke bestanden zijn dan absoluut noodzakelijk voor iemand om mijn library te kunnen gebruiken?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/tdd/",
	"title": "3. Test Driven Development",
	"tags": [],
	"description": "",
	"content": "  Wat is de beste manier om het aantal bugs in code te reduceren?\n Test-Driven Development TDD (Test-Driven Development) is een hulpmiddel bij softwareontwikkeling om minder fouten te maken en sneller fouten te vinden, door éérst een test te schrijven en dan pas de implementatie. Die (unit) test zal dus eerst falen (ROOD), want er is nog helemaal geen code, en na de correcte implementatie uiteindelijk slagen (GROEN).\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; T{\"Write FAILING test\"} D{\"Write IMPLEMENTATION\"} C{\"Run test SUCCEEDS\"} S[\"Start Hier\"] S -- T T -- D D -- C C -- T  Testen worden in opgenomen in een build omgeving, waardoor alle testen automatisch worden gecontroleerd bij bijvoorbeeld het compileren, starten, of packagen van de applicatie. Op deze manier krijgt men onmiddellijk feedback van modules die door bepaalde wijzigingen niet meer werken zoals beschreven in de test.\nEen TDD Scenario Stel dat een programma een notie van periodes nodig heeft, waarvan elke periode een start- en einddatum heeft, die al dan niet ingevuld kunnen zijn. Een contract bijvoorbeeld geldt voor een periode van bepaalde duur, waarvan beide data ingevuld zijn, of voor gelukkige werknemers voor een periode van onbepaalde duur, waarvan de einddatum ontbreekt:\nclass Contract() { private lateinit periode: Periode } data class Periode(val startDatum: LocalDate, val eindDatum: LocalDate) public class Contract { private Periode periode; } public class Periode { private Date startDatum; private Date eindDatum; }  We wensen aan de Periode klasse een methode toe te voegen om te controleren of periodes overlappen, zodat de volgende statement mogelijk is: periode1.overlaptMet(periode2).\n1. Schrijf Falende Testen Voordat de methode wordt opgevuld met een implementatie dienen we na te denken over de mogelijke gevallen van een periode. Wat kan overlappen met wat? Wanneer geeft de methode true terug, en wanneer false? Wat met lege waardes?\n Het standaard geval: beide periodes hebben start- en einddatum ingevuld, en de periodes overlappen.  @Test fun `Gegeven biede periodes met datum ingevuld Wanneer overlaptMet Dan is true`() { val jandec19 = Periode(LocalDate.of(2019, 1, 1), LocalDate.of(2019, 12, 31)) val maartnov19 = Periode(LocalDate.of(2019, 3, 1), LocalDate.of(2019, 11, 31)) assertTrue { jandec19.overlaptMet(maartnov19) } } @Test public void GegevenBeidePeriodesDatumIngevuld_Wanneeroverlapt_DanIsTrue() { var jandec19 = new Periode(new Date(2019, 01, 01), new Date(2019, 12, 31)); var maartnov19 = new Periode(new Date(2019, 03, 01), new Date(2019, 11, 31)); assertThat(jandec19.overlaptMet(maartnov19), is(true)); }   Beide periodes hebben start- en einddatum ingevuld, en periodes overlappen niet.  @Test fun `Gegeven niet overlappende periodes Wanneer overlaptMet Dan is false`() { val jandec19 = Periode(LocalDate.of(2019, 1, 1), LocalDate.of(2019, 12, 31)) val maartnov20 = Periode(LocalDate.of(2020, 3, 1), LocalDate.of(2020, 11, 31)) assertFalse { jandec19.overlaptMet(maartnov20) } } @Test public void gegevenNietOverlappendePeriodes_WanneerOverlaptMet_DanIsFalse() { var jandec19 = new Periode(new Date(2019, 01, 01), new Date(2019, 12, 31)); var maartnov20 = new Periode(new Date(2020, 03, 01), new Date(2020, 11, 31)); assertThat(jandec19.overlaptMet(maartnov20), is(false)); }   \u0026hellip; Er zijn nog tal van mogelijkheden, waarvan voornamelijk de extreme gevallen belangrijk zijn om de kans op bugs te minimaliseren. Immers, gebruikers van onze Periode klasse kunnen onbewust null mee doorgeven, waardoor de methode onverwachte waardes teruggeeft.  In Kotlin is het mogelijk om een volle zin te gebruiken als functienaam met behulp van backtics. Dit wordt in de praktijk vaak gebruik in testen op voorwaarde dat je je strict houdt aan een conventie voor de naamgeving. Zoals hierboven alle testen in de vorm van Gegeven\u0026hellip; Wanneer\u0026hellip; Dan\u0026hellip; geschreven zijn. Zulke testen zijn niet alleen in code makkelijker te lezen en begrijpen, maar ook in het JUnit output window. Java enthousiastelingen zullen zich moeten beperken tot camelCase of snake_case.\n De testen compileren niet, omdat de methode overlaptMet() nog niet bestaat. Voordat we overschakelen naar het schrijven van de implementatie willen we eerst de testen zien ROOD kleuren, waarbij wel de bestaande code nog compileert:\ndata class Periode(val startDatum: LocalDate, val eindDatum: LocalDate) { fun overlaptMet(anderePeriode: Periode): Boolean { throw UnsupportedOperationException() } } public class Periode { private Date startDatum; private Date eindDatum; public boolean overlaptMet(Periode anderePeriode) { throw new UnsupportedOperationException(); } }  De aanwezigheid van het skelet van de methode zorgt er voor dat de testen compileren. De inhoud, die een UnsupportedOperationException gooit, dient nog aangevuld te worden in stap 2. Op dit punt falen alle testen (met hopelijk als oorzaak de voorgaande exception).\n2. Schrijf Implementatie Pas nadat er minstens 4 verschillende testen werden voorzien (standaard gevallen, edge cases, null cases, \u0026hellip;), kan aan met een gerust hart aan de implementatie worden gewerkt:\nfun overlaptMet(ander: Periode): Boolean = startDatum.isAfter(ander.startDatum) \u0026amp;\u0026amp; eindDatum.isBefore(ander.eindDatum) } public boolean overlaptMet(Periode anderePeriode) { return startDatum.after(anderePeriode.startDatum) \u0026amp;\u0026amp; eindDatum.before(anderePeriode.eindDatum); }  3. Voer Testen uit Deze eerste aanzet verandert de deprimerende rode kleur van minstens één test naar GROEN. Echter, lang niet alle testen zijn in orde. Voer de testen uit na elke wijziging in implementatie totdat alles in orde is. Het is mogelijk om terug naar stap 1 te gaan en extra test gevallen toe te voegen.\n4. Pas code aan (en herbegin) De cyclus is compleet: red, green, refactor, red, green, refactor, \u0026hellip;\nWat is \u0026lsquo;refactoring\u0026rsquo;?\n Structuur veranderen, zonder de inhoud te wijzigen.\n Als de overlaptMet() methode veel conditionele checks bevat is de kans groot dat bij elke groene test de inhoud stelselmatig ingewikkelder wordt, door bijvoorbeeld het veelvuldig gebruik van if statements. In dat geval is het verbeteren van de code, zonder de functionaliteit te wijzigen, een refactor stap. Na elke refactor stap verifiëer je de wijziging door middel van de testen.\nVoel jij je veilig genoeg om grote wijzigingen door te voeren zonder te kunnen vertrouwen op een vangnet van testen? Wij als docenten alvast niet.\nUnit Testing Basics Wat is Unit Testing Unit testen zijn stukjes code die productie code verifiëren op verschillende niveau\u0026rsquo;s. Het resultaat van een test is GROEN (geslaagd) of ROOD (gefaald met een bepaalde reden). Een collectie van testen geeft ontwikkelaars het zelfvertrouwen om stukken van de applicatie te wijzigen met de zekerheid dat de aanwezige testen rapporteren wat nog werkt, en wat niet. Het uitvoeren van deze testen gebeurt meestal in een IDE zoals IntelliJ voor Java, of Visual Studio voor C#, zoals deze screenshot:\n  De visuele output van NUnit in C#  Elke validatieregel wordt apart opgelijst in één test. Als de validate() methode 4 regels test, zijn er minstens 4 testen geimplementeerd. In de praktijk is dat meestal meer omdat edge cases - uitzonderingsgevallen zoals null checks - ook aanzien worden als een apart testgeval.\nEigenschappen van een goede test Elke unit test is F.I.R.S.T.:\n Fast. Elk nieuw stukje functionaliteit vereist nieuwe testen, waarbij de bestaande testen ook worden uitgevoerd. In de praktijk zijn er duizenden testen die per compile worden overlopen. Als elke test één seconde duurt, wordt dit wel erg lang wachten\u0026hellip; Isolated. Elke test bevat zijn eigen test scenario dat géén invloed heeft op een andere test. Vermijd ten allen tijden het gebruik van het keyword static, en kuis tijdelijk aangemaakte data op, om te vermijden dat andere testen worden beïnvloed. Repeatable. Elke test dient hetzelfde resultaat te tonen, of die nu éénmalig wordt uitgevoerd, of honderden keren achter elkaar. State kan hier typisch roet in het eten gooien. Self-Validating. Geen manuele inspectie is vereist om te controleren wat de status van de test is. Een falende foutboodschap is een duidelijke foutboodschap. Thorough. Testen moeten alle scenarios dekken: denk terug aan edge cases, randgevallen, het gebruik van null, het opvangen van mogelijke Exceptions, \u0026hellip;  Het Raamwerk van een test Test Libraries bestaande uit twee componenten Een test framework, zoals JUnit voor Java, MSUnit/NUnit voor C#, of Jasmine voor Javascript, bevat twee delen:\n1. Het Test Harnas Een \u0026lsquo;harnas\u0026rsquo; is het concept waar alle testen aan worden opgehangen. Het harnas identificeert en verzamelt testen, en het harnas stelt het mogelijk om bepaalde of alle testen uit te voeren. De ingebouwde Test UI in IntelliJ fungeert hier als visueel harnas. Elke test methode, een public void methode geannoteerd met @Test, wordt herkent als mogelijke test. Bovenstaande screenshot van NUnit in C# is een visuele weergave van de resultaten, verzameld door dit systeem.\nGradle en het JUnit harnas verzamelen data van testen in de vorm van HTML rapporten.\n2. Het Assertion Framework Naast het harnas, die zorgt voor het uitvoeren van testen, hebben we ook een verificatie framework nodig, dat fouten genereert wanneer nodig, om te bepalen of een test al dan niet geslaagd is. Dit gebeurt typisch met assertions, die vereisten dat een argument een bepaalde waarde heeft. Is dit niet het geval, wordt er een AssertionError exception gegooid, die door het harnas herkent wordt, met als resultaat een falende test.\nAssertions zijn er in alle kleuren en gewichten, waarbij in de oefeningen de statische methode assertThat() wordt gebruikt, die leeft in  org.hamcrest.MatcherAssert. Hamcrest is een plugin library die ons in staat stelt om een fluent API te gebruiken in plaats van moeilijk leesbare assertions:\nimport org.hamcrest.CoreMatchers.`is` as Is @Test fun `test with default assertions`() { val result = doStuff() AssertEquals(result, 3) // arg1: expected, arg2: actual } @Test fun `test with hamcrest matchers`() { val result = doStuff() assertThat(result, Is(3)) } @Test public void testWithDefaultAssertions() { var result = doStuff(); AssertEquals(result, 3); // arg1: expected, arg2: actual } @Test public void testWithHamcrestMatchers() { var result = doStuff(); assertThat(result, is(3)); }  Het tweede voorbeeld leest als een vloeiende zin, terwijl de eerste AssertEquals() vereist dat als eerste argument de expected value wordt meegegeven - dit is vaak het omgekeerde van wat wij verwachten!\nHamCrest Matchers API Documentation\nEen populair alternatief voor HamCrest is bijvoorbeeld AssertJ\u0026mdash;en voor Kotlin-only code is MockK de betere keuze. De keuze is aan jou: alle frameworks bieden ongeveer dezelfde fluent API aan met ongeveer dezelfde features.\nMerk op dat in Kotlin is een reserved keyword is. Oplossing 1: gebruik backticks. Oplossing 2: import als uppercase Is met behulp van  import org.hamcrest.CoreMatchers.`is` as Is (enkele backtick). Opossing 3: Gebruik een Kotlin-idiomatic assertion framework zoals MockK. Zie TDD in de praktijk voor meer informatie.\n Arrange, Act, Assert De body van een test bestaat typisch uit drie delen:\n@Test fun `Given arranged When acting Then some expected result`() { // 1. Arrange  val instance = ClassToTest(arg1, arg2) // 2. Act  val result = instance.callStuff() // 3. Assert  assertThat(result, Is(true)) } @Test public void givenArranged_whenActing_thenSomeExpectedResult() { // 1. Arrange  var instance = new ClassToTest(arg1, arg2); // 2. Act  var result = instance.callStuff(); // 3. Assert  assertThat(result, is(true)); }   Arrange. Het klaarzetten van data, nodig om te testen, zoals een instantie van een klasse die wordt getest, met nodige parameters/DB waardes/\u0026hellip; Act. Het uitvoeren van de methode die wordt getest, en opvangen van het resultaat. Assert. Het verifiëren van het resultaat van de methode.  Setup, Execute, Teardown Wanneer de Arrange stap dezelfde is voor een serie van testen, kunnen we dit veralgemenen naar een @Before methode, die voor het uitvoeren van bepaalde of alle testen wordt uitgevoerd. Op dezelfde manier kan data worden opgekuist na elke test met een @After methode - dit noemt men de teardown stap.\nJUnit 4 en JUnit 5 verschillen hierin op niveau van gebruik. Vanaf JUnit 5 werkt men met @BeforeEach/@BeforeAll. Raadpleeg de documentatie voor meer informatie over het verschil tussen each/all en tussen v4/v5. Voorbeelden van JUnit 5 testen zijn terug te vinden in de SESsy Library applicatie.\nSoorten van Testen Er zijn drie grote types van testen:\n  De drie soorten van testen.  1. Unit Testing (GROEN) Een unit test test zaken op individueel niveau, per klasse dus. De methodes van de Periode klasse testen zijn unit testen: er zijn geen andere klasses mee gemoeid. De meeste testen zijn unit testen. Hoe kleiner het blokje op bovenstaande figuur, hoe beter de F.I.R.S.T. principes kunnen nageleefd worden. Immers, hoe meer systemen opgezet moeten worden voordat het assertion framework zijn ding kan doen, hoe meer tijd verloren, en hoe meer tijd de test in totaal nodig heeft om zijn resultaat te verwerken.\n2. Integration Testing (ORANJE) Een integratie test test het integratie pad tussen twee verschillende klasses. Hier ligt de nadruk op interactie in plaats van op individuele functionaliteit, zoals bij de unit test. We willen bijvoorbeeld controleren of een bepaalde service wel iets wegschrijft naar de database, maar het schrijven zelf is op unit niveau bij de database reeds getest. Waar wij nu interesse in hebben, is de interactie tussen service en database, niet de functionaliteit van de database.\nTypische eigenschappen van integration testen:\n Test geïntegreerd met externen. (db, webservice, \u0026hellip;) Test integratie twee verschillende lagen. Trager dan unit tests. Minder test cases.  Test Doubles Stel dat we een Service en een Repository klasse hebben gemaakt, waarvan de tweede gegevens wegschrijft naar een database. Als we de eerste klasse willen testen, willen we niet weer een verbinding opstellen, omdat dit te traag is (1), én omdat dit al getest is (2):\nclass Repository() { fun save(c: Customer) { // insert into...  } } class Service(val repository: Repository) { fun updateCustomerWallet(c: Customer, balance: double) { c.balance = balance repository.save(c) } } public class Repository { public void save(Customer c) { // insert into ...  } } public class Service { private Repository repository; public void updateCustomerWallet(Customer c, double balance) { c.setBalance(balance); repository.save(c); } }  Hoe testen we de updateCustomerWallet() methode, zonder de effectieve implementatie van save() te moeten gebruiken? Door middel van test doubles.\n  I\u0026#39;ll Be Back.  Zoals Arnie in zijn films bij gevaarlijke scenes een stuntman lookalike gebruikt, zo gaan wij in onze code een Repository lookalike gebruiken, zodat de Service dénkt dat hij save() aanroept, terwijl dit in werkelijkheid niet zo is. Daarvoor moet de repository een interface zijn. We passen in principe een design pattern toe, waarbij in de service een repository instantie wordt geïnjecteerd:\ninterface Repository { fun save(c: Customer) } class RepositoryDBImpl : Repository { override fun save(c: Cusomter) { // insert into...  } } class RepositoryForTesting : Repository { override fun save(c: Customer) { // do nothing!  } } class Service(val repository: Repository) public interface Repository { void save(Customer c); } public class RepositoryDBImpl implements Repository { @Override void save(Customer c) { // insert into...  } } public class RepositoryForTesting implements Repository { @Override public void save(Customer c) { // do nothing!  } } public class Service { private Repository repository; public Service(Repository r) { this.repository = r; } }  In de test wordt een instantie van RepositoryForTesting in service gebruikt in plaats van de effectieve RepositoryDBImpl. De test klasse gedraagt zich als een Repository, omdat deze de betreffende interface implementeert. De Service klasse weet niet welke implementatie van de interface binnen komt: daar kan bij het integration testing handig gebruk van worden gemaakt.\nEen werkend voorbeeld hiervan is terug te vinden in de SESsy library applicatie.\n3. End-To-End Testing (ROOD) Een laatste groep van testen genaamd end-to-end testen, ofwel scenario testen, testen de héle applicatie, van UI tot DB. Voor een webapplicatie betekent dit het simuleren van de acties van de gebruiker, door op knoppen te klikken en te navigeren doorheen de applicatie, waarbij bepaalde verwachtingen worden afgetoetst. Bijvoorbeeld, klik op \u0026lsquo;voeg toe aan winkelmandje\u0026rsquo;, ga naar \u0026lsquo;winkelmandje\u0026rsquo;, controleer of het item effectief is toegevoegd.\nTypische eigenschappen van end-to-end testen:\n Test hele applicatie! Niet alle limieten. Traag, moeilijker onderhoudbaar. Test integratie van alle lagen.  Een werkend voorbeeld hiervan is terug te vinden in de SESsy library applicatie.\nDe SESsy applicatie maakt gebruik van WebDriver, een interface die Selenium aanstuurt die browsers automatiseert. Op die manier kan men eenvoudig commando\u0026rsquo;s doorsturen zoals surf naar daar, klik hier op, wacht x seconden, verifieer dat hier dat staat, \u0026hellip; Dit is één test scenario in totaal.\n   In plaats van dit in (Java) code te schrijven, is het echter ook mogelijk om de Selenium IDE extentie voor Google Chrome of Mozilla Firefox te gebruiken. Deze browser extentie laat recorden in de browser zelf toe, en vergemakkelijkt het gebruik (er is geen nood meer aan het vanbuiten kennen van zulke commando\u0026rsquo;s). Dit wordt in de praktijk vaak gebruikt door software analisten of testers die niet de technische kennis hebben om te programmeren, maar toch deel zijn van het ontwikkelteam.\nRecente versies van de Selenium IDE plugin bewaren scenario\u0026rsquo;s in .side bestanden, wat een JSON-notatie is. Oudere versies bewaren commando\u0026rsquo;s in het .html formaat. deze bestanden bevatten een lijst van je opgenomen records:\n \u0026quot;tests\u0026quot;: [{ \u0026quot;id\u0026quot;: \u0026quot;73bc78d5-1ca2-44c4-9ad2-6ccfe7cba5fe\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;bla\u0026quot;, \u0026quot;commands\u0026quot;: [{ \u0026quot;id\u0026quot;: \u0026quot;f192c93d-064a-4298-8d84-a44fd617622b\u0026quot;, \u0026quot;comment\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;open\u0026quot;, \u0026quot;target\u0026quot;: \u0026quot;/mattersof/workshops\u0026quot;, \u0026quot;targets\u0026quot;: [], \u0026quot;value\u0026quot;: \u0026quot;\u0026quot; }, { \u0026quot;id\u0026quot;: \u0026quot;b94bd35b-0fc0-4ede-9b47-7e24d78126e8\u0026quot;, \u0026quot;comment\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;setWindowSize\u0026quot;, \u0026quot;target\u0026quot;: \u0026quot;1365x691\u0026quot;, \u0026quot;targets\u0026quot;: [], \u0026quot;value\u0026quot;: \u0026quot;\u0026quot; }, { ...  Er zijn moderne alternatieven voor Webdriver-based Java testen. De front-end van de SESsy library werkt met Vue.js, en dit kan je makkelijk testen met behulp van https://webdriver.io/ in JavaScript. Een voorbeeldje van zo\u0026rsquo;n geautomatiseerde test staat op de front page. WebdriverIO integreert ook met ChromeDevTools, waardoor je kan doen alsof je met een smartphone surft naar een pagina: browser.emulateDevice('iPhone X').\n Labo oefeningen Fork het startproject via  Github Classroom.\nOpgave 1 De Artisanale Bakkers Associatie vertrouwt op uw technische bekwaamheid om hun probleem op te lossen. Er wordt veel Hasseltse Speculaas gebakken, maar niemand weet precies wat de beste Speculaas is. Schrijf een methode die speculaas beoordeelt op basis van de ingrediënten. De methode, in de klasse Speculaas, zou er zo uit moeten zien:\nfun beoordeel(): Int { // TODO ...  } public int beoordeel() { // TODO ...  }  De functie geeft een nummer terug - hoe hoger dit nummer, hoe beter de beoordeling en hoe gelukkiger de bakker. Een speculaas kan de volgende ingrediënten bevatten: kruiden, boter, suiker, eieren, melk, honing, bloem, zout. Elke eigenschap is een nummer dat de hoeveelheid in gram uitdrukt.\nHet principe is simpel: hoe meer ingrediënten, hoe beter de beoordeling.\nKijk naar een voorbeeld test hoe de methodes te hanteren. Er zijn al enkele testen voorzien. Die kan je uitvoeren met IntelliJ door op het groen pijltje te drukken, of met Gralde: ./gradlew.bat test (Op Unix: ./gradlew test). Dit genereert een test rapport HTML bestand in de build/test map.\nWe zijn dus geïnteresseerd in edge cases. Probeer alle mogelijkheden te controleren. Denk bij het testen aan de volgende zaken:\n Hoe zit het met een industriële speculaas, zonder kruiden of boter? Wat doet de funcite beoordeel als het argument null is? Wat als een speculaas wordt meegegeven zonder ingrediënten?  Opgave 2 Fork het startproject via  Github Classroom.\nA. Misluke login pogingen Er is een foutje geslopen in de login module, waardoor Abigail nog steeds kan inloggen, maar Jos plots niet meer. De senior programmeur in ons team heeft de bug geïdentificeerd en beweert dat het in een stukje oude code zit, maar hij heeft geen tijd om dit op te lossen. Nu is het aan jou.\nimport java.util.regex.Pattern; import java.util.regex.Pattern.CASE_INSENSITIVE; fun control(username: String): Boolean { val pattern = Pattern.compile(\u0026#34;^(?=[a-z]{2})(?=.{4,26})(?=[^.]*\\\\.?[^.]*$)(?=[^_]*_?[^_]*$)[\\\\w.]+$\u0026#34;, CASE_INSENSITIVE) return pattern.matcher(username).matches() } import java.util.regex.Pattern; import static java.util.regex.Pattern.CASE_INSENSITIVE; public static boolean control(String username) { Pattern pattern = Pattern.compile(\u0026#34;^(?=[a-z]{2})(?=.{4,26})(?=[^.]*\\\\.?[^.]*$)(?=[^_]*_?[^_]*$)[\\\\w.]+$\u0026#34;, CASE_INSENSITIVE); return pattern.matcher(username).matches(); }  Deze functie geeft true terug als Abigail probeert in te loggen, en false als Jos probeert in te loggen. Hoe komt dit? Schrijf éérst een falende test!\nB. URL Verificatie fouten Een tweede bug wordt gemeld: URL verificatie features werken plots niet meer. Deze methode faalt steeds, ook al zijn er reeds unit testen voorzien. Het probleem is dat HTTPS URLs met een SSL certificaat niet werken. Je onderzocht de URL verificatie code en vond de volgende verdachte regels:\nimport java.util.regex.Pattern; import java.util.regex.Pattern.CASE_INSENSITIVE; fun verifyUrl(url: String): Boolean { val pattern = Pattern.compile(\u0026#34;http:\\\\/\\\\/(www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.[a-z]{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\+.~#?\u0026amp;//=]*)\u0026#34;, CASE_INSENSITIVE) return pattern.matcher(url).matches() } import java.util.regex.Pattern; import static java.util.regex.Pattern.CASE_INSENSITIVE; public static boolean verifyUrl(String url) { Pattern pattern = Pattern.compile(\u0026#34;http:\\\\/\\\\/(www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.[a-z]{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\+.~#?\u0026amp;//=]*)\u0026#34;, CASE_INSENSITIVE); return pattern.matcher(url).matches(); }  De code blijkt reeds unit testen te hebben, dus schrijf éérst een falende test (in VerifierTests).\nOpgave 3 Werk een volledige implementatie van Periode.overlaptMet() uit, zoals hierboven uitgelegd.\nOpgave 4 Dit is een vervolgopgave van de code van Opgave 1. Werk verder op dat bestaand project, in diezelfde repository!\n Een verkoopster werkt in een (goede) speculaasfabriek. De verkoopster wilt graag 2 EUR aanrekenen per speculaas die de fabriek produceert. Echter, als de klant meer dan 5 stuks verkoopt, mag er een korting van 10% worden aangerekend.\nfun verkoop(): Double { val gebakken = speculaasFabriek.bak() // TODO ...  } public double verkoop() { var gebakken = speculaasFabriek.bak(); // TODO ...  }  Je ziet aan bovenstaande code dat de speculaasfabriek instantie wordt gebruikt. We hebben dus eigenlijk geen controle op de hoeveelheid speculaas die deze fabriek produceert.\nUnit testen Hoe kunnen we dan toch nog testen wat we willen testen? Mogelijke scenario\u0026rsquo;s:\n De fabriek produceert niets. De klant betaalt niets. De fabriek produceert minder dan 5 speculaasjes. De klant betaalt per stuk, 2 EUR. De fabriek produceert meer dan 5 stuks. De klant krijgt 10% korting op zijn totaal.  Hoe controleer ik het gedrag van de fabriek? Mockito is verreweg het meest populaire Unit Test Framework dat bovenop JUnit wordt gebruikt om heel snel Test Doubles en integratietesten op te bouwen.\n   Gebruik dus hiervoor Mockito, en injecteer een mock(SpeculaasFabriek.class) in de verkoopster (de setter is reeds voorzien).\nLees op https://site.mockito.org hoe je het framework moet gebruiken. (Volledige javadoc) Denk aan de volgende zaken:\n Hoe include ik Mockito als een dependency in mijn project? Hoe gebruik ik de API om een Test Double/mock aan te maken? Hoe valideer ik verwachtingen die ik heb van deze Test Double?  Het gebruik van Mockito en MockK: een uitgewerkt voorbeeld.\nOpgave 5 Gebruik Selenium IDE om een test scenario op te nemen van de SESsy applicatie. Start deze eerst lokaal, en vertrek vanuit het localhost base address http://localhost:8080/#/. Hanteer de volgende scenario\u0026rsquo;s:\n Als anoniempje, zoek op \u0026lsquo;art\u0026rsquo;, klik op detail, klik op uitlenen. Verifieer dat er een waarschuwingsboodschap verschijnt dat je niet kan uitlenen. Als slechte uitlener, zoek op \u0026lsquo;art\u0026rsquo;, klik op detail, klik op uitlenen. Verifieer dat er een boodschap verschijnt dat het gelukt is, en dat de knop veranderde naar \u0026lsquo;Terugbrengen?\u0026rsquo;. Klik op terugbrengen. Verifieer dat er een boodschap verschijnt dat het gelukt is. Als anoniempje, log in (een van beide rollen). Verifieer dat login naar logout verandert. Logout. Verifieer dat logout naar login verandert.  Bewaar dit scenario, opgenomen met de Selenium IDE, in bestand opgave5.html (of .side voor nieuwe versies) in de root de repository van opgave 1 (de eerste Github Classroom link).\n Je zal voor deze opgave dus de lokale SESsy applicatie moeten starten, en de Selenium (Chromium/Firefox) plugin moeten installeren: zie hierboven.\nDenkvragen  Wat doe je met opgenomen test materiaal in Selenium IDE? Hoe integreeg je dit in een build systeen? Met andere woorden, hoe zorg je er voor dat deze testen automatisch draaien, telkens er iets in de code wordt gewijzigd? Hoe vertaal je de Selenium IDE commando\u0026rsquo;s naar WebDriver Java commando\u0026rsquo;s?  Extra leermateriaal Lees de volgende artikels om een beter inzicht te krijgen in de capaciteiten van de Test-Driven benadering:\n The Art of Agile Development: Test-Driven Development Benefits of TDD: Wikipedia Let\u0026rsquo;s Play: TDD Screencasts HamCrest Matchers API Documentation Integration Testing: Mocks Aren\u0026rsquo;t Stubs (Martin Fowler)  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/algoritmes/",
	"title": "4. Algoritmes en Datastructuren",
	"tags": [],
	"description": "",
	"content": " Hoorcolleges: zie Toledo Cursusmateriaal Test-Driven Development met algoritmes: Capita Selecta  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/patterns/",
	"title": "5. Design Patterns",
	"tags": [],
	"description": "",
	"content": "Wat is dat, een patroon? Patronen zijn voor het mensenlijk brein eenvoudig herkenbaar: we zien stukjes van iets die we al eens ergens anders gezien hebben. Blokjes op een bepaalde manier ingekleurd, gehaakte patroontjes van een dekbed, Fibonacci spiralen in bloemblaadjes en zaadjes, \u0026hellip; Wanneer we programmeren, geldt dit principe ook: blokken code die herbruikt worden om eenvoudige oplossingen te bieden voor complexe problemen.\n  Een (creatief) patroon?  Een pattern is een herkenbaar en herhalende blok van eigenschappen die herbruikt kan worden. In het geval van softwareontwikkeling zijn patterns structuren in code die herbruikt worden om code eenvoudiger, beter leesbaar, en beter in onderhoud te maken. Deze structuren zijn in feite pre-fab oplossingen voor gelijkaardige problemen.\nIngebouwde patronen Een constructor is een begrip in Java dat ook geclassificeerd kan worden als patroon, omdat het constant terugkomt bij de creatie van objecten en een hulpmiddel is dat een bepaalt probleem helpt oplossen: het voert stukjes code uit bij het aanmaken van een object.\nclass Appel { val kcal = 160 } public class Appel { private int kcal; public Appel() { kcal = 160; } }  Een nieuwe appel aanmaken, Appel jonagold = new Appel(); stelt kcal automatisch gelijk aan 160. Dit is uiteraard een ingebouwd principe dat deel uitmaakt van de programmeertaal zelf. Dit concept kunnen we verder doortrekken door patronen van oplossingen te maken die het ons makkelijker maakt om toekomstige gelijkaardige problemen aan te pakken.\nModel-View-Controller Een van de meest populaire patronen is het Model-View-Controller (MVC) systeem. Dit patroon stelt dat om UI logica eenvoudig te scheiden van domein logica, men drie aparte lagen dient aan te maken.\n Het model, het belangrijkste, stelt ons domein voor: de objecten waar het om draait in de applicatie. De view, de UI, is de presentatielaag die de gebruiker te zien krijgt als hij de applicatie hanteert. Achterliggend wordt er met model objecten gewerkt. De controller verbindt de UI met het model en onderliggende lagen. Events vanuit de UI worden hier bijvoorbeeld opgevangen.  mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; M[Model] V[View] C[Controller] C -- V V -- M C -- M  De controller kent zowel de view als het model. De view kent enkel het model. Het model kent niemand buiten zichzelf. Op die manier is het eenvoudig om in de applicatie te migreren naar nieuwe presentatie lagen, zoals van een typische client-server applicatie naar een moderne website, gehost op een (virtuele) server. Dit principe kan telkens opnieuw worden toegepast, voor ontelbare applicaties. Men spreekt hier dus van een herhalend patroon, dat kan helpen bij het oplossen van een probleem.\nTypes van patronen Er zijn op elk niveau patronen in code te herkennen. Zoals de constructor aantoont, zijn er op niveau van de compiler en/of taal zelf verschillende patronen die we constant onbewust hanteren:\n klasse structuren constructors properties subklassen interfacing formatting threading \u0026hellip;  Dit zijn allemaal structuren die in elk programma terug komt.\nOp applicatie niveau, in de code zelf, zijn er eveneens talloze mogelijkheden. De meest populaire software engineering design patterns zijn beschreven in het boek Design Patterns: Elements of Reusable Object-Oriented Software.  Op enterprise niveau, tussen applicaties in, onderscheiden we ook patronen, om bijvoorbeeld efficiënte te communiceren tussen verschillende partijen. Gegevensuitwisseling kan door middel van REST/SOAP/FTP/\u0026hellip; Die vorm van berichtgeving is op zijn beurt weer herbruikbaar.\nVoor het vak Software Engineering Skills beperken we ons tot enkele voorbeelden van software design patterns op applicatie niveau. Een overzicht is terug te vinden op de hoofdpagina van het vak.\nWaarvoor staat het woord \u0026lsquo;design\u0026rsquo;? Het proces van idee tot software doorloopt verschillende stappen, in verschillende iteraties, waarvan één de design stap:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; I[\"Idee \"] D[Design] C[Code] T[Test] De[Deploy] I -- D I -- I D -- C D -- D C -- T C -- C T -- De T -- T  Nadenken over het ontwerp voordat je jezelf overgeeft aan het schrijven van code is een belangrijke stap, zoals we gezien hebben in het vak \u0026lsquo;Software ontwerp in Java\u0026rsquo;. Tijdens het ontwerpen, of nadenken over de oplossing, houden ervaren ontwikkelaars ook al rekening met de welgende patronen. Het is dus belangrijk om te weten dat het gebruiken van patronen zich niet beperkt tot de code schrijven stap.\nVanaf nu veronderstellen we dat jullie weten hoe een nieuw Kotlin-specifiek project aan te maken voor wie de design patterns oefeningen in Kotlin wenst op te lossen. De repositories op GitHub bevatten vanaf hier enkel nog Java code. Zie de TDD Exercises GitHub repositories voor Kotlin templates.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/lifecycle/",
	"title": "6. Software Management",
	"tags": [],
	"description": "",
	"content": "Software Management  Continuous Integration \u0026amp; Deployment Software Management: Skills (1), Scrum (2)  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/extra/",
	"title": "Extra informatie",
	"tags": [],
	"description": "",
	"content": "Extra informatie  Gebruikte Software: een overzicht De \u0026lsquo;SESsy Library\u0026rsquo; WebApp: installatie \u0026amp; configuratie De \u0026lsquo;SESsy Library\u0026rsquo; WebApp: extra oefeningen Gradle build tools  Github Classroom links  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/dependency-management/gradle/",
	"title": "2.1 Java Gradle projecten",
	"tags": [],
	"description": "",
	"content": " Helps teams build, automate and deliver better software, faster.volgens de gradle.org website.\n Wat is dat, een build tool? Gradle is een build tool die de automatisatie van releasen, builden, testen, configureren, dependencies en libraries managen, \u0026hellip; eenvoudiger maakt. Kort gezegd: het maakt het leven van een ontwikkelaar eenvoudiger. In een config bestand genaamd build.gradle schrijft men met Groovy, een dynamische taal bovenop de JVM, op een descriptieve manier hoe Gradle de applicatie moet beheren.\nAndere bekende build tools:\n Maven, Ant (in XML) voor Java (C/Q)Make (custom config) voor C/C++ yarn, grunt, gulp, (in JS) \u0026hellip; voor JS nuget (custom config, XML) voor .NET  Naast het beheren van compilaties, verzorgt Gradle ook libraries. Het is dus ook een dependency management systeem, zoals Composer voor PHP of Node Package Manager voor NodeJS.\nOntleding van een Gradle config file De meest eenvoudige buildfile is terug te vinden in de singleton oefening:\n plugins { id 'java' } group 'be.kuleuven.ses' version '1.0-SNAPSHOT' sourceCompatibility = 1.10 repositories { mavenCentral() } dependencies { testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0' testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine' testImplementation group: 'org.hamcrest', name: 'hamcrest-library', version: '2.2' } test { useJUnitPlatform() }  Hier onderscheiden we de volgende zaken:\n Het project is een java 10 project (er zijn ook nog andere talen op de JVM) Het project komt van be.kuleuven.ses, versie 1.0-SNAPSHOT. Dependencies downloaden via de standaard maven central (ingebouwde URL).  Hiervan moet Gradle junit-jupiter-api 5.6.0 downloaden voor de testen Hiervan moet Gradle junit-jupiter-engine (zelfde versie) gebruiken om testen te runnen Hiervan moet Gradle hamcrest-library 2.2 downloaden voor de testen    Dependencies vallen (meestal) in twee categorieën:\n implementation (productie dependencies) testImplementation (test dependencies)  Merk op dat een typisch gradle project geen jars mee zipt, zoals de oefeningen. Die worden dus automatisch door deze tool gedownload, en in de juiste map geplaatst.\nVoor het SESsy Library project wordt ook Gradle gebruikt, en is de config file iets ingewikkelder, door de inclusie van eigen \u0026ldquo;tasks\u0026rdquo;. (te raadplegen op  Github)\nMerk op dat bij Gradle 6.x, t.o.v. de vorige versies, de de runtime dependencies nu implementation in plaats van compile heten, en de test dependencies testImplementation en testRuntimeOnly in plaats van testCompile. Zie ook: Declaring dependencies in de Gradle docs.\n Ontleding van een Gradle project mappenstructuur Als we kijken naar de bestanden- en mappenstructuur van singleton oefening, vinden we dit terug:\n build/ src/ main/ java/ be/ package1/ ClassMain ClassZ test/ java/ be/ package1/ ClassMainTest ClassZTest resources/ css/ js/ gradle/ wrapper/ gradle-wrapper.jar gradle-wrapper.properties build.gradle gradlew.bat gradlew settings.gradle  Hier onderscheiden we de volgende zaken:\n Broncode (.java bestanden) in src/main/java en src/test/java, met productie- en testcode gescheiden. Gecompileerde code (.class bestanden) in de build/ (of ook wel out) folder. Eventueel resources voor webapps e.d. (images, css, \u0026hellip;) gradle map, en executable (gradlew.bat win en shell script voor unix) gradle settings en build file.  Wat gebeurt er nu precies als je gradlew.bat uitvoert?\n Download de juiste versie van Gradle zelf (!! dus installatie is niet nodig), afhankelijk van de specificaties in de properties file. Download de juiste libraries om het project te kunnen runnen.  Aan deze wrapper kan je commando\u0026rsquo;s meegeven. Bijvoorbeeld, gradlew.bat test:\n Wouters-Air:singleton wgroeneveld$ ./gradlew test  Task :test FAILED ShoppingCartResourceTest  get_fromMultipleResources_shouldNotIncreaseDBHandleVarCount FAILED java.lang.AssertionError at ShoppingCartResourceTest.java:25 2 tests completed, 1 failed FAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':test'.  There were failing tests. See the report at: file:///Users/jefklak/development/brainbaking/content/teaching/ses/singleton/build/reports/tests/test/index.html  Dit is exact hetzelfde als in IntelliJ de testen uitvoeren met de knop \u0026lsquo;Run\u0026rsquo;:\n   Waarom een build tool gebruiken? De grootste voordelen hiervan zijn onder andere:\n Een kleine voetafdruk van de broncode (repository). Het is niet nodig om jars als libraries in een lib/ folder zelf bij te houden: Gradle doet dit immers voor jou. Een project bootstrappen in luttele seconden: download code, voer de Gradle wrapper uit, en alles wordt vanzelf klaargezet (de juiste Gradle versie, de juiste library versies, \u0026hellip;) Platform-onafhankelijk processen besturen die altijd op dezelfde manier werken: een taak uitvoeren op mijn PC doet exact hetzelfde als bij jou, dankzij de beschrijving van de stappen in de config file.  Het is bijvoorbeeld bij de oefeningen eenvoudig om een test library als junit mee te leveren, zonder de bestanden zelf aan te leveren, dankzij het regeltje testCompile group: 'junit', name: 'junit', version: '4.12' in de dependencies block.\nGradle en Maven integratie Gradle voorziet een plugin genaamd \u0026lsquo;maven-publish\u0026rsquo; die deze bestanden automatisch aanmaakt. Activeer de plugin en voeg een publishing tag toe met de volgende properties:\n plugins { id 'java' id 'maven-publish' // toevoegen! } publishing { publications { maven(MavenPublication) { groupId = project.group.toString() version = version artifactId = 'projectnaam' from components.java } } repositories { maven { url = \"/Users/wgroeneveld/development/java/maven-repo\" } } }  Deze uitbreiding voegt de target publish toe aan Gradle. Dus: ./gradlew publish publiceert de nodige bestanden in de aangegeven folder. Een Gradle project die daar gebruik van wenst te maken dient enkel een tweede Maven Repository plaats te definiëren:\n repositories { mavenCentral() maven { url = \"/Users/wgroeneveld/development/java/maven-repo\" } }  Gradle en JUnit integratie JUnit 5 splitst de test library op in een aantal submodules, waarvan er twee belangrijke zijn die we nodig hebben om te testen:\n junit-jupiter-api - nodig om testen te SCHRIJVEN (de API waar @BeforeEach e.a. in zitten) junit-jupiter-engine - nodig om testen UIT TE VOEREN (cmdline interface)  Aangezien Gradle verschillende test bibliotheken ondersteund, zoals ook TestNG, dient men in de Gradle build file ondersteuning voor elk framework te activeren. Dit is enkel nodig bij cmdline uitvoeren van de testen. Als je beslist om enkel binnen IntelliJ testen uit te voeren, verzorgt IntelliJ zelf dit, en is de jupiter-engine ook niet nodig.\n test { useJUnitPlatform() testLogging.showStandardStreams = true } dependencies { // for WRITING tests, this will suffice: testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0' // for RUNNING tests (cmdline, without IntelliJ), this is also needed: testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine' }  Optionele test libraries zoals Hamcrest en Selenium/WebDriver kunnen daarna ook worden toegevoegd onder de testImplementation groep.\nMerk op dat dit betekent dat dependencies in de testRuntimeOnly groep eigenlijk runtime dependencies zijn: deze worden niet gebruikt om mee te builden. Denk aan het verschil tussen statisch en dynamisch linken in C.\n Welke Task moet ik uitvoeren? ./gradlew tasks --all voorziet een overzicht van alle beschikbare taken voor een bepaald Gradle project, opgesplitst per fase (build tasks, build setup tasks, documentation tasks, help tasks, verification tasks). Plugins voorzien vaak extra tasks, zoals bovenstaande maven plugin.\nBelangrijke taken zijn onder andere:\n test: voer alle unit testen uit. Een rapport hiervan is beschikbaar op build/reports/tests/test/index.html. clean: verwijder alle binaries en metadata. build: compile en test het project. publish: (maven plugin) publiceert naar een repository. jar: compile en package in een jar bestand javadoc: (plugin) genereert HTML javadoc. Een rapport hiervan is beschikbaar op build/docs/javadoc/index.html.  Onderstaande screenshot is een voorbeeld van een Unit Test HTML rapport voor de SESsy library:\n   Ik wil meer output bij het uitvoeren van mijn tasks! De standaard output geeft enkel weer of er iets gelukt is of niet:\n Wouters-Air:sessylibrary wgroeneveld$ ./gradlew shadowjar BUILD SUCCESSFUL in 9s 3 actionable tasks: 1 executed, 2 up-to-date  Meer informatie kan met de volgende parameters:\n --info, output LogLevel INFO. Veel irrelevante info wordt ook getoond. --warning-mode all, toont detail informatie van warning messages --stacktrace, toont de detail stacktrace bij exceptions  De Gradle (wrapper) Upgraden Indien de Gralde wrapper een oudere versie aanmaakt (\u0026lt; v6), update met gradle wrapper --gradle-version 6.0.1. Gradle versie 6 of groter is vereist voor JDK 13 of groter.\nGradle/Java compatibiliteitsmatrix:\n JDK 12 of ouder: Gradle 5.x JDK 13: Gradle 6.x of nieuwer JDK 14: Gradle 6.3 of nieuwer JDK 15: NIET compatibel (02/10/2020)! Zie docs  Indien je de fout \u0026ldquo;Could not initialize class org.codehaus.groovy.reflection.ReflectionCache\u0026rdquo; krijgt, betekent dit dat je JDK te nieuw is voor de gradle versie. Controleer de huidige gralde versie met gradle --info of kijk in gradle/wrapper/gradle-wrapper.properties.\nMeer links en tutorials:  Officiële Gradle docs. Officiële Gradle guides: creating a new build Gradle cheatsheet voorbeeld config file Gradle common commands  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/dependency-management/kotlin-gradle/",
	"title": "2.2 Kotlin Gradle projecten",
	"tags": [],
	"description": "",
	"content": "De build.gradle bestanden die tot nu toe in de cursus zijn beschreven (zie 2.1 Java Gradle Projecten), werden geschreven in de Groovy programmeertaal, een multi-purpose dynamische taal voor het Java platform. Aangezien we voor Kotlin projecten geen Groovy, noch Java, maar Kotlin schrijven, zou het fijn zijn om de syntax van de Gradle configuratie óók te kunnen wijzigen naar Kotlin.\nDat kan.\nDaarvoor vink je bij het aanmaken van nieuwe projecten in IntelliJ het vinkje Kotlin DSL Build Script aan:\n  Het eerste vinkje, onder \u0026#39;Project SDK\u0026#39;  Dan wordt een build.gradle.kts script file gegenereerd. Onthoud: de .kts extensie betekent dat de Kotlin DSL actief is. Wat betekent dat concreet? De syntax van het bestand is lichtjes gewijzigd. Dit is een typische minimale config file in Kotlin:\nplugins { kotlin(\u0026quot;jvm\u0026quot;) version \u0026quot;1.5.21\u0026quot; } group = \u0026quot;org.example\u0026quot; version = \u0026quot;1.0-SNAPSHOT\u0026quot; repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026quot;stdlib\u0026quot;)) testImplementation(kotlin(\u0026quot;test\u0026quot;)) testImplementation(\u0026quot;org.hamcrest:hamcrest:2.2\u0026quot;) } tasks.test { useJUnitPlatform() } De wijzigingen zijn onder andere:\n Alles is een functie! dependencies is een functie die een block binnen pakt, dat een closure is. Dependencies worden gewrapped in een functie in plaats van een gewone string. De Kotlin versie wordt bovenaan ingesteld, samen met het doelplatform (\u0026quot;jvm\u0026quot;) Kotlin komt met built-in JUnit 5 compatibiliteit als je useJUnitPlatform() activeert.  Meer lezen? Vast met een instelling?\n Official Kotlin documentation on Gradle Gradle Kotlin DSL Primer  Je kan gerust een Kotlin project aanmaken zonder te kiezen voor de Kotlin DSL. In dat geval blijft de build file de standaard Groovy-style build.gradle. Het betekent echter drie talen moeten beheersen: Java, Groovy, én Kotlin. Je kan ook zowel Java als Kotlin compilen; dan verschijnen er twee entries onder de plugins {} block: kotlin() voor src/main/kotlin source files en java() voor src/main/java source files.\n Geavanceerde instellingen Dit is geen deel van de cursus maar soms wel handig om te weten.\nStel een JDK doel in om compatibiliteit met oude Java runtimes te behouden:\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile val compileKotlin: KotlinCompile by tasks compileKotlin.kotlinOptions.jvmTarget = \u0026quot;1.6\u0026quot; Zie Kotlin compiler options voor een lijst van mogelijkheden.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/tdd/in-de-praktijk/",
	"title": "3.1 TDD In de praktijk",
	"tags": [],
	"description": "",
	"content": "The Java way: Mockito Mockito is verreweg het meest populaire Java-specifieke Unit Test Framework dat bovenop JUnit wordt gebruikt om heel snel Test Doubles en integratietesten op te bouwen.\n   Lees op https://site.mockito.org hoe je het framework moet gebruiken. (Klik op de knoppen WHY en HOW bovenaan! Volledige javadoc) Denk aan de volgende zaken:\n Hoe include ik Mockito als een dependency in mijn project? Hoe gebruik ik de API om een Test Double/mock aan te maken? Hoe valideer ik verwachtingen die ik heb van deze Test Double?  Een interface \u0026lsquo;mocken\u0026rsquo;: the hard way Zoals aangehaald in de TDD noties kan een eigen implementatie van een interface worden gemaakt die als Test Double werkt (denk aan Arnie\u0026rsquo;s stuntman). Het vervelende is dat deze klasse enkel maar wordt gebruikt in test code, dus niet in productie code. Mockito maakt dit dynamisch aan, zonder dat er ooit het keyword class bij aan de pas komt.\n  I\u0026#39;ll Be Back.  Stel, Arnold gaat acteren voor de nieuwe film Die Hard: In A Deepen Beek (uit in 2025 - Bruce had geen zin meer). Hij moet daarvoor een aantal fantastische stunts uithalen, die hij niet graag zelf zou doen. De volgende interface definieert een \u0026lsquo;Arnold\u0026rsquo;, waarbij doBackFlip() de gevaarlijke stunt is (resultaat is true indien geslaagd):\ninterface IllBeBack { fun doBackFlip(): Boolean } public interface IllBeBack { boolean doBackFlip(); }  De casting crew en de director verwachten dat tijdens een opname 3x een backflip succesvol wordt uitgevoerd. Indien deze niet lukt, wordt de take opnieuw genomen. Dit manifesteert zich in code in de vorm van een RuntimeException. De One And Only Arnold had op dat moment een crisisvergadering in Californië en kon niet aanwezig zijn op de set. Gelukkig zijn er lookalikes en stuntmannen genoeg:\nclass ArnieLookalike : IllBeBack { override fun doBackFlip(): Boolean = false } class StuntmanArnie : IllBeBack { override fun doBackFlip(): Boolean = true } public class ArnieLookalike implements IllBeBack { @Override public boolean doBackFlip() { return false; } } public class StuntmanArnie implements IllBeBack { @Override public boolean doBackFlip() { return true; } }  Enkel StuntmanArnie is fysiek krachtig genoeg om consistent de backflip uit te voeren. De lookalike ziet er uit zoals Arnold, maar bakt jammer genoeg van de scene niet zo veel. Hieronder een blueprint van de opname code:\nclass DieHardInADeepenBeek(var arnoldActor: IllBeBack) { fun recordActOne() { var succeeded = true for(i in 1..3) { succeeded = succeeded \u0026amp;\u0026amp; arnoldActor.doBackFlip() } if(!succeeded) throw RuntimeException(\u0026#34;do that again, please...\u0026#34;) } } public class DieHardInADeepenBeek { private IllBeBack arnoldActor; public void setArnoldActor(IllBeBack actor) { this.arnoldActor = actor; } public void recordActOne() { boolean succeeded = true; for(int i = 1; i \u0026lt;= 3; i++) { succeeded = succeeded \u0026amp;\u0026amp; arnoldActor.doBackFlip(); } if(!succeeded) { throw new RuntimeException(\u0026#34;do that again, please...\u0026#34;); } } }  De hamvraag is nu: hoe testen we de logica in recordActOne? Daarvoor zal de backflip soms moeten lukken, en soms ook niet. We hebben dus zowel een ArnieLookalike als StuntmanArnie implementatie nodig:\nclass DieHardInADeepenBeekTests { @Test fun `Given failing backflip When recording act one Then redo the whole thing`() { // 1. Arrange  val movie = DieHardInADeepenBeek(ArnieLookalike()) // 2/3 act/assert in one  assertThrows(RuntimeException::class.java) { movie.recordActOne() } } @Test fun `Given a good backflip When recording act one Then its a success`() { // 1. Arrange  val movie = DieHardInADeepenBeek(StuntmanArnie()) // 2/3 act/assert in one  assertDoesNotThrow { movie.recordActOne() } } } public class DieHardInADeepenBeekTests { @Test public void recordActOne_backflipFails_haveToRedoTheWholeThing() { // 1. Arrange  var movie = new DieHardInADeepenBeek(); var actor = new ArnieLookalike(); movie.setArnoldActor(actor); // 2. act  assertThrows(RuntimeException.class, () -\u0026gt; { movie.recordActOne() }); // 3. assert (in annotation)  } @Test public void recordActOne_backflipSucceeds_ok() { // 1. Arrange  var movie = new DieHardInADeepenBeek(); var actor = new StuntmanArnie(); movie.setArnoldActor(actor); // 2. act  assertDoesNotThrow(() -\u0026gt; { movie.recordActOne() }); // 3. assert (not needed, doesn\u0026#39;t crash)  // assertTrue(true);  } }  Een interface \u0026lsquo;mocken\u0026rsquo;: the easy way In plaats van de ArnieLookalike en StuntmanArnie klasses zelf te maken, kunnen we hier Mockito het zware werk laten doen door gebruik te maken van de mock() methode. De testen worden dan lichtjes anders, omdat we daarin het gedrag van de mock eerst moeten bepalen voordat we naar de act en assert stappen kunnen gaan:\nimport org.mockito.Mockito.`when` as When class DieHardInADeepenBeekTests { @Test fun `Given failing backflip When recording act one Then redo the whole thing`() { // 1. Arrange  val actor = mock(IllBeBack::class.java) When(actor.doBackFlip()).thenReturn(false) val movie = DieHardInADeepenBeek(actor) // 2/3 act/assert in one  assertThrows(RuntimeException::class.java) { movie.recordActOne() } } @Test fun `Given a good backflip When recording act one Then its a success`() { // 1. Arrange  val actor = mock(IllBeBack::class.java) When(actor.doBackFlip()).thenReturn(true) val movie = DieHardInADeepenBeek(actor) // 2/3 act/assert in one  assertDoesNotThrow { movie.recordActOne() } } } public class DieHardInADeepenBeekTests { @Test public void recordActOne_backflipFails_haveToRedoTheWholeThing() { // 1. Arrange  var movie = new DieHardInADeepenBeek(); var actor = mock(IllBeBack.class); when(actor.doBackFlip()).thenReturn(false); movie.setArnoldActor(actor); // 2. act  assertThrows(RuntimeException.class, () -\u0026gt; { movie.recordActOne() }); // 3. assert (in annotation)  } @Test public void recordActOne_backflipSucceeds_ok() { // 1. Arrange  var movie = new DieHardInADeepenBeek(); var actor = mock(IllBeBack.class); when(actor.doBackFlip()).thenReturn(true); movie.setArnoldActor(actor); // 2. act  assertDoesNotThrow(() -\u0026gt; { movie.recordActOne() }); // 3. assert (not needed, doesn\u0026#39;t throw)  } }  Het geheim zit hem in de mock() en when() methodes, waarmee we het gedrag van de mock implementatie kunnen aansturen. Dit werd vroeger manueel geïmplementeerd, maar die klasses zijn nu niet meer nodig.\nLees op https://site.mockito.org hoe je het framework moet gebruiken. (Klik op de knoppen WHY en HOW bovenaan! Volledige javadoc)\nThe Kotlin way: MockK Mockito\u0026rsquo;s is en when methodes zijn reserved keywords in Kotlin, en dat zorgt de aanwezigheid van ofwel vervelende backticks, ofwel een import alias met een hoofdletter (zie Kotlin voorbeelden hierboven). Om mocks \u0026ldquo;de Kotlin-idiomatic way\u0026rdquo; te schrijven, gebruiken we een framework dat geschreven werd met Kotlin in gedachten: MockK.\nBovenstaande DieHardInADeepenBeekTests klasse kan herschreven worden door Mockito-specifieke calls te vervagnen met MockK-specifieke calls. Het resultaat is als volgt:\nclass DieHardInADeepenBeekTests { @Test fun `Given failing backflip When recording act one Then redo the whole thing`() { // 1. Arrange  val actor = mockk\u0026lt;IllBeBack\u0026gt;() every { actor.doBackFlip() } returns false val movie = DieHardInADeepenBeek(actor) // 2/3 act/assert in one  assertThrows(RuntimeException::class.java) { movie.recordActOne() } } @Test fun `Given a good backflip When recording act one Then its a success`() { // 1. Arrange  val actor = mock\u0026lt;IllBeBack\u0026gt;() every { actor.doBackFlip() } returns true val movie = DieHardInADeepenBeek(actor) // 2/3 act/assert in one  assertDoesNotThrow { movie.recordActOne() } } } Mockito.mock(MyClass::class.java) in Mockito wordt mockk\u0026lt;MyClass\u0026gt;() in MockK. When(x.y()).thenReturn(z) in Mockito wordt every { x.y() } returns z in MockK. Merk op dat de assertions niet veranderen: Mockito/MockK zijn mocking frameworks die de ARRANGE stap vereenvoudigen, niet de ASSERT stap\u0026mdash;dat wordt nog steeds overgelaten aan JUnit 4/5, eventueel bijgestaan door Hamcrest.\nVoor meer voorbeelden, zie examples/kotlin/mocking in de cursus git repository.\nTDD in een groter project De SESsy library webapplicatie bevat ook unit-, integratie- en endtoend-testen die een meer \u0026lsquo;real-life\u0026rsquo; omgeving simuleren met een grotere codebase. Zij die zoeken naar een beter begrip van het concept TDD en de implementatie ervan in de dagelijkse wereld, kunnen daar hun oren en ogen de kost geven. We moedigen tevens het wijzigen van testen aan om te kijken wat er gebeurt!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/tdd/capita/",
	"title": "3.2 TDD Capita Selecta: Algoritmes",
	"tags": [],
	"description": "",
	"content": "Test-First Een algoritme ontwerpen Neem eerst de volgende noties terug door:\n Test Driven Development principes  Dit labo gaan we ons focussen op het praktisch gebruik van TDD en unit testen ter ondersteuning van het opbouwen van een algoritme, ter oplossing van een probleem. Alle TDD concepten zijn reeds uitgelegd in het Test Driven Development labo. We gaan onmiddellijk verder met de oefeningen:\nLabo oefeningen Via  Github Classroom. Lege projecten, maak zelf in een nieuwe map voor elke opgave een Gradle project aan.\nOpgave 1 Deel A Leo wil graag een boodschap versturen naar Marie, die aan de andere kant van de straat woont. Het probleem is dat Leo zijn berichten vaak worden onderschept door de vervelende buurman Jos. Jos moeit zich graag met het leven van anderen, waar Leo en Marie een stokje voor willen steken.\nZe spreken telefonisch met mekaar af een gedeelde geheime sleutel te gebruiken om geschreven berichten te versleutelen, zodat Jos ze niet meer kan lezen. Dit gaat als volgt:\n Alle letters worden 3 posities naar rechts opgeschoven in het alfabet.\n Dit wordt ook wel \u0026lsquo;ROT-3 encryption\u0026rsquo; genoemd. Enkele voorbeelden:\n \u0026ldquo;jos is een loser\u0026rdquo; wordt \u0026ldquo;mrv lv hhq orvhu\u0026rdquo; \u0026ldquo;Ik hou van jou, Marie!\u0026rdquo; wordt \u0026ldquo;Ln krx ydq mrx, Pdulh!\u0026rdquo; \u0026ldquo;???\u0026rdquo; blijft \u0026ldquo;???\u0026rdquo; \u0026quot;\u0026quot; blijft \u0026quot;\u0026quot;  Speciale tekens blijven ongewijzigd.\nSchrijf eerst unit testen voor alle mogelijke gevallen die je kan bedenken, gebaseerd op de voorbeelden, voor de methode String encrypt(String s). Pas wanneer alle gevallen door testen zijn bedekt, mag je aan de implementatie beginnen. Re-run de testen tussendoor om jezelf ervan te verzekeren dat je vooruitgang boekt (RED-GREEN-REFACTOR).\nDeel B Na enkele dagen puzzelen heeft Jos ontdekt welk geheim systeem Leo en Marie er op na houden! Marie doet een voorstel tot verstrenging van het systeem, waar Leo onmiddellijk mee akkoord gaat. De extra regel geldt als volgt:\n Na de ROT-3 verwisselen we de posities voor elk paar karakters in het bericht.\n Enkele voorbeelden:\n \u0026ldquo;jos is een loser\u0026rdquo; wordt \u0026ldquo;rm vvlh qho vruh\u0026rdquo; \u0026ldquo;Ik hou van jou, Marie!\u0026rdquo; wordt \u0026ldquo;nLk xry qdm xr ,dPlu!h\u0026rdquo; \u0026ldquo;???\u0026rdquo; blijft \u0026ldquo;???\u0026rdquo; \u0026ldquo;?!?\u0026rdquo; wordt \u0026ldquo;!??\u0026rdquo; \u0026ldquo;jup\u0026rdquo; wordt \u0026ldquo;xms\u0026rdquo; \u0026quot;\u0026quot; blijft \u0026quot;\u0026quot;  Pas de testen aan en schrijf testen bij waar nodig. Verander dan pas de implementatie. Merk op dat bij een oneven aantal karakters, het laatste karakter niet van plaats wisselt.\nDeel C Nu de encrypt() methode correct werd geïmplementeerd, kunnen we ons bezig houden met de manier waarop het programma boodschappen in- en uitleest. Een systeem dat ook wordt gebruikt bij de Vlaamse Programmeerwedstrijd, is het inlezen via de standard input stdin en uitlezen via standard output stdout. Je kan hiervoor het volgende gebruiken:\nfun main(args: Array\u0026lt;String\u0026gt;) { val sc = Scanner(System.in) // ...  println(\u0026#34;output\u0026#34;) } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // ...  System.out.println(\u0026#34;output\u0026#34;);  Lees in de Scanner Javadoc hoe je de volgende regels van stdin inleest.\nDe input is een bestand (bewaren als voorbeeld.invoer) (downloadlink) dat er zo uit ziet:\n 5 jos is een loser Ik hou van jou, Marie! ??? ?!? jup  De eerste regel beschrijft het aantal regels die versleuteld moeten worden. Voor elke regel dien je de encrypt() regels van deel B toe te passen. Dit wordt weggeschreven naar stdout met behulp van System.out.println().\nDe output ziet er zo uit:\n 1 rm vvlh qho vruh 2 nLk xry qdm xr ,dPlu!h 3 ??? 4 !?? 5 xms  Elke regel begint met een volgnummer vanaf 1, voor elke versleutelde zin, gevolgd door een spatie. Vanaf dan volgt de versleutelde tekst, volgens dezelfde regels als deel B.\nOm het Java programma te kunnen draaien en testen kan je (in Unix) het inputbestand lezen via het pipe commando: cat voorbeeld.invoer | java -cp . Main. Vergeet niet het programma eerst te compileren met javac Main.java.\nValideer je programma aan de hand van de voorbeeld invoer hierboven. De unit testen van deel B kan je herbruiken.\n Als het programma de verwachte output genereert, kan je je oplossing laten valideren tegen veel meer input: download encryption-input.txt hier. Als je zelf wilt kijken hoe deze input werd gegenereerd: download EncryptionGenerate.java hier.  Java files zelf compileren Zoals je hierboven ziet kan je javac zelf oproepen in plaats van Gradle dit te laten doen. Er zijn echter een paar spelregels die belangrijk zijn als je zelf compileert in combinatie met packages. De -d optie voorziet een output folder, zoals Gradle die in de root een map build/ gebruikt voor zijn gecompileerde .class files. Compileer dus altijd vanaf de root folder van je project! Voorbeeld structuur:\n build.gradle src/ main/ java/ package/ Main.java  Compileer in root: javac -d build/ src/main/java/package/Main.java. Dit levert je het volgende op:\n build.gradle src/ main/ java/ package/ Main.java build/ package/ Main.class  Het programma oproepen, ook vanuit de root, kan je met java -cp build/ package.Main. Dus: geef de build map mee met het classpath (1) en voorzie de fully qualified name van de klasse (2), inclusief de package naam. Dit is belangrijk omdat het best zou kunnen dat er verschillende Main klasses in je applicatie bestaan, in verschillende packages.\nGebruik je geen speciale packages (aangeduid in het begin van de java file met package blabla;), dan kan je in dezelfde folder als je source compileren en als classpath de huidige folder, . of ./, meegeven. Voor simpele programma\u0026rsquo;s, zoals deze oefeningen, kan dit volstaan.\nVoor Kotlin geldt exact hetzelfde, alleen wordt javac vervangen door kotlinc. Vergeet nooit -include-runtime mee te geven: zie Kotlin docs: command-line compiler.\n Opgave 2 Kristien is een modebewuste vrouw die graag - en regelmatig - nieuwe schoenen koopt. Het probleem is van praktische aard: de schoenenkast geraakt te vol. Ze heeft de opdracht gegeven aan haar man om nieuwe schoenenkasten te bouwen met de juiste afmetingen. Op die manier is ze ervan overtuigd dat er nog wel een paar of twee aangeschaft kan worden (waar ze waarschijnlijk gelijk in heeft).\nMaak een Java programma dat uit de standard input stdin leest welke schoenen Kristien heeft. Het programma schrijft naar standard output stdout de uitkomst, namelijk wat de afmetingen van de kast zijn zodat alle schoenen netjes passen. Hanteer dezelfde methode als deel C van opgave 1.\nDe input is een bestand dat er zo uit ziet (downloadlink):\n 3 5 36 37 35 36 38 2 38 38 2 36 36  De eerste regel beschrijft het aantal kasten dat gevuld moeten worden. Voor elke kast dicteert de eerste regel het aantal schoenen, en de volgende regels de schoenmaat voor elke schoen in die kast. Bovenstaande input zegt dus: er zijn 3 kasten, in kast 1 zitten 5 schoenen met maat 36, 37, 35, 36, 38, in kast 2 zitten 2 schoenen met maat 38, 38, \u0026hellip;\nSchoenen met exact dezelfde maat strikt kleiner dan maat 38 kunnen op elkaar geplaatst worden om plaats te besparen, met een maximum van 2. Dat betekent dat voor bovenstaand voorbeeld, de eerste kast er zo zou uit zien: 35, 36/36, 37, 38. (De schoenen mogen dus verhuisd worden van volgorde)\nDe output ziet er zo uit:\n 1 15x146 2 10x76 3 15x36  Elke regel begint met een volgnummer vanaf 1, voor elke kast, gevolgd door een spatie. Vanaf dan volgen de afmetingen van de kast, gescheiden met \u0026lsquo;x\u0026rsquo;, waarvan bij kast 1 15 de hoogte van de kast is (dit is altijd ofwel 10, ofwel 15 als er schoenen op elkaar werden geplaatst), en 146 de lengte van de kast is.\nDe lengte van de kast bereken je door de schoenmaten op te tellen: 35 + 36 + 37 + 38. Maat 36 tellen we in de lengte maar éénmalig omdat ze op elkaar liggen. In de tweede kast moeten de schoenen naast elkaar liggen omdat ze te groot zijn, terwijl in de derde kast dit wel op elkaar kan.\nOm het Java programma te kunnen draaien en testen kan je (in Unix) het inputbestand lezen via het pipe commando: cat voorbeeld.invoer | java -cp . Main. Vergeet niet het programma eerst te compileren met javac Main.java.\nValideer je programma aan de hand van de voorbeeld invoer hierboven. Schrijf uiteraard eerst unit testen.\n Als het programma de verwachte output genereert, kan je je oplossing laten valideren tegen veel meer input: download schoenen-input.txt hier. Als je zelf wilt kijken hoe deze input werd gegenereerd: download SchoenenGenerate.java hier.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/tdd/tdd-ex-feedback/",
	"title": "3.3 TDD opgave feedback",
	"tags": [],
	"description": "",
	"content": "Deze opgave feedback werd gegeven in academiejaar 2021-2022 voor opgave 1, 4, en 5. We laten dit hier staan voor jullie ter referentie zodat het kan helpen om laatste controles voor het indienen van de opgaves tot een goed einde te brengen.\nAlgemene feedback Bij het indienen van een opdracht worden de volgende zaken altijd eerst nagekeken:\n Compileert het programma? Zijn alle testen groen?  Aangezien het vaak over veel opgaves gaat wordt dit gescript met behulp van Gradle. Na het downloaden van de opdracht wordt vaak het commando ./gradlew clean test uitgevoerd, die ook impliciet build. Zorg er dan ook steeds voor dat je project correct build vóórdat je indient! Test dit zelf met het commando in je opdrachtprompt, los van IntelliJ. Waarom? Omdat individuele testen uitvoeren in IntelliJ niet betekent dat je hele project compileert.\nEen niet-compilerend ingediend project komt over als erg slordig werk. Het zou kunnen dat er discrepanties zijn tussen JDK versies, waar ook rekening mee gehouden wordt, maar in de praktijk merken we vaak dat nalatigheden zoals het vergeten van een constructor veel punten kost.\nZorg ervoor dat je Gradle buildfile in orde is. Zonder een syntactisch correcte build.gradle file kan het project niet builden met het gradlew commando. Dat komt opnieuw over als erg slordig, zeker omdat er in dit vak nadruk gelegd wordt op dependency management.\nZorg ervoor dat testen groen zijn. Verwijder niet-relevante testen die misschien zijn opgesteld om te experimenteren. Controleer dit simpelweg met het gradle commando, los van het comfort van de IDE!\nZorg ervoor dat je code leesbaar is. Dit is het vak Software Engineering, waarbij we constant de nadruk leggen op zaken als clean code, TDD, en software design. Als je programma doet wat het moet doen, betekent dit nog niet dat het volgens deze principes als goede code aanschouwd wordt.\n3.1 Opgave 4: integratie testen Hieronder volgen een aantal veel voorkomende fouten, die eenvoudig te vermijden zijn als je aandacht schenkt aan je unit test designs.\nFout 1: assertions verkeerd gebruiken Bijvoorbeeld:\n@Test public void someTestMethod() { int result = someCalculation(2, 5); Assert.assertTrue(result == 5 * 20); } Als deze test faalt, krijg je de boodschap: expected true, but was false. That\u0026rsquo;s it. Heb je daar iets aan, buiten dat de test faalt? Nee: je zal breakpoints moeten plaatsen om te zien wat er precies mis ging. assertTrue() is hier de verkeerde keuze. Gebruik nooit == om een expressie om te vormen naar een boolean statement. Laat dit aan de juiste assertion method over:\n@Test public void someTestMethod() { int result = someCalculation(2, 5); Assert.assertEquals(100, result); } Nu krijg je bijvoorbeeld de boodschap expected 100, but was 45. Dat is veel duidelijker. Vermijd ook het a-la-minute berekenen van de expected outcome (5 * 20 is minder expliciet dan 100). Gebruik maken van de betere leesbaarheid van Hamcrest is nog beter: assertThat(result, is(100)).\nFout 2: expected en actual in assertions omkeren In veel xUnit test frameworks, inclusief JUnit, verwachten assertion methodes eerst de expected value, daarna pas de actual.\nDus niet Assert.assertEquals(result, 100); maar Assert.assertEquals(100, result);. De test geeft misschien hetzelfde resultaat (rood/groen), maar de boodschap en interpretatie is een wereld van verschil.\nOpnieuw, leesbaarheid primeert hier, en Hamcrest helpt en keert dit wel correct om.\nFout 3: mocks als fields definiëren Een Mockito mock (of een zelfgeschreven Test Double) mag je nooit herbruiken. Er is state aan verbonden, die bij voor elke test uniek moet zijn. Dus niet:\npublic class MyTest { private MyInterface mockObj = Mockito.mock(MyInterface.class); @Test public void test1() { Mockito.when(mockObj.doStuff()).thenReturn(10); // ...  } @Test public void test2() { Mockito.when(mockObj.doMoreStuff()).thenReturn(true); // ...  } } Het probleem hier is dat na het uitvoeren van test1(), je mockObj nog steeds 10 gaat teruggeven bij het oproepen van doStuff(), omdat de mock in test2 hetzelfde object is! Dit geeft heel vreemde side effects en kan tot erg buggy testen leiden waarvan de bugs moeilijk te achterhalen zijn.\nOm dit te vermijden maak je elke mock aan in de test zelf. Ook al heb je voor elke test dezelfde soort mock nodig. Dus:\npublic class MyTest { @Test public void test1() { MyInterface mockObj = Mockito.mock(MyInterface.class); Mockito.when(mockObj.doStuff()).thenReturn(10); // ...  } @Test public void test2() { MyInterface mockObj = Mockito.mock(MyInterface.class); Mockito.when(mockObj.doMoreStuff()).thenReturn(true); // ...  } } Dit lijkt niet goed te zijn omdat we code regels dupliceren, maar hiermee encapsuleren we mockObj: deze variabele is nu een lokale variabele en geen field, en zal dus stoppen met bestaan na het uitvoeren van de test.\nVergeet niet de F.I.R.S.T. principes van unit testen, waar we fouten tegen maken als we dit niet doen.\nFout 4: onduidelijke test namen Dit spreekt voor zich. In bovenstaande voorbeelden staat test1 en test2, maar niemand weet precies wat dit betekent, en welke condities ze aftesten. Dit is uiteraard slechts een voorbeeld, maar helaas dienen studenten soms ook zulke testnamen in.\nAls een vuistregel is het een goed idee om in testnamen het volgende te verwerken:\n De methode die je wenst te testen De condities van de test Het effect  Bijvoorbeeld: encrypt_withEmptyString_returnsEmptyString, of encrypt_withSpaces_ignoresSpecialChars, en niet encryptTest1 of encryptDoesStuff. Test methodes mogen lang zijn: zolang opnieuw leesbaarheid primeert is alles oké, inclusief snake casing (gebruik maken van _) of camelCasing. Vergeet niet dat in Kotlin een hele zin mag. Schrijf bijvoorbeeld test funs in de stijl van Given blah When this Then that. Zie het unit testen hoofdstuk.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/tdd/tdd-challenge/",
	"title": "3.3 The TDD proglang challenge",
	"tags": [],
	"description": "",
	"content": "1. De opgave: Wimbledon Tennisspelers staan weer klaar om een balletje heen en weer over de netten te sturen. In plaats van een tennisbal, zijn karakters voorzien die deel uitmaken van een mysterieuze zin, die ontcijferd moet worden.\nDe decodering van deze `Wimbledon-versleutelde' zin bestaat uit het eerste karakter, gevolgd door het laatste karakter, het tweede karakter, het voorlaatste karakter, het derde karakter, enzovoort.\n   Ontcijfer de zinnen zoals aangegeven in bovenstaande figuur om populaire tennis quotes te ontdekken.\nVoorbeeld input Oea ie.mtat n W'entwies u o,cnw ev.erse a ybtb,rta o re Dtn enspae srsy oemasntigt s.uo nho ne vL.ki iryl intagia Download meer voorbeeld input.\nVoorbeeld uitvoer One at a time. We're not waiters, but boy, can we serve. Dating a tennis player is risky. Love means nothing to us. Download meer voorbeeld uitvoer.\nOplossing in JavaScript Signatuur: output = decrypt(input)\nTesten Geschreven met test harnas en framework https://jestjs.io/\nconst decrypt = require(\u0026#39;../src/decrypt\u0026#39;) describe(\u0026#34;wimbledon decrypt\u0026#34;, () =\u0026gt; { test(\u0026#34;decrypt voorbeeld input 1 resulteert in voorbeeld output 1\u0026#34;, () =\u0026gt; { expect(decrypt(\u0026#34;Oea ie.mtat n\u0026#34;)).toEqual(\u0026#34;One at a time.\u0026#34;) }) test(\u0026#34;decrypt voorbeeld input 2 resulteert in voorbeeld output 2\u0026#34;, () =\u0026gt; { expect(decrypt(\u0026#34;W\u0026#39;entwies u o,cnw ev.erse a ybtb,rta o re\u0026#34;)).toEqual(\u0026#34;We\u0026#39;re not waiters, but boy, can we serve.\u0026#34;) }) test(\u0026#34;decrypt voorbeeld input 3 resulteert in voorbeeld output 3\u0026#34;, () =\u0026gt; { expect(decrypt(\u0026#34;Dtn enspae srsy oemasntigt s.uo nho ne vL.ki iryl intagia\u0026#34;)).toEqual(\u0026#34;Dating a tennis player is risky. Love means nothing to us.\u0026#34;) }) test(\u0026#34;decrypt een lege string blijft een lege string\u0026#34;, () =\u0026gt; { expect(decrypt(\u0026#34;\u0026#34;)).toEqual(\u0026#34;\u0026#34;) }) test(\u0026#34;decrypt null of undefined blijft een lege string\u0026#34;, () =\u0026gt; { expect(decrypt(null)).toEqual(\u0026#34;\u0026#34;) expect(decrypt(undefined)).toEqual(\u0026#34;\u0026#34;) }) }) Code Array.prototype.head = function() { return this.splice(0, 1) } Array.prototype.tail = function() { return this.splice(-1) } const decrypt = (inputText) =\u0026gt; { let output = \u0026#34;\u0026#34; const invoer = inputText?.split(\u0026#34;\u0026#34;) while(invoer?.length \u0026gt; 0) { output += invoer.head() if(invoer.length \u0026gt; 0) { output += invoer.tail() } } return output } module.exports = decrypt Je kan dit zelf verifiëren door bovenstaande code te evalueren in de browser (buiten de module regel), en te experimenteren met decrypt calls!\n2. De challenge Start hier: Github Classroom!\nDit is een groepsopdracht. Dat wil zeggen dat de GitHub classroom repositories niet individueel zijn, maar dat je per groepje één repository aanmaakt om te kunnen samenwerken. Puntenverdeling /10: actief meewerken en íets proberen = 10. Het is NIET belangrijk of jullie de opdracht met succes weten af te werken of niet!\nHerimplementeer bovenstaande opdracht, test-first!, in één van de volgende, voor jullie totaal onbekende (vandaar géén Python/Java/C++/PHP) programmeertalen (nummer = aantal ogen van dobbelsteen):\n Julia ** Go * Rust * Elexir ** Ruby * Kotlin * Lua * Clojure **  Je kan niet kiezen, maar een worp met een D8 dobbelsteen, het geluk dus, bepaalt welke taal je zal aanwenden:\n   https://dm.tools/dice/\nDe hoeveelheid * duiden aan hoe groot de verwachtte uitdaging is. Groepen die de \u0026ldquo;pech\u0026rdquo; hebben een moeilijkere taal voorgeschoteld te krijgen: geen paniek. Jullie krijgen een bonuspunt op de volgende taak!\nTips voor een vliegende start  Verdeel taken onder jullie team! Gebruik git efficiënt. Probeer zo snel mogelijk cmd-line een \u0026ldquo;println('hello world')\u0026rdquo; programma te compileren. Zoek hiervoor naar de \u0026ldquo;Get Started!\u0026rdquo; knop bij bovenstaande links. Ontrafel daarna hoe unit testing werkt in die taal. De kans is groot dat er meerdere test harnas frameworks bestaan. Kies gewoon degene die je het eerste tegenkomt. Schrijf een \u0026ldquo;assertThat(true, is(true))\u0026rdquo; test en zoek uit hoe je deze testen uitvoert. Verspil geen tijd met de opgave/testen zelf: de oplossing is er al! Belangrijkere vragen:  Hoe loop je over karakters in die taal? Hoe splits je een string, als je denkt dat dat nodig is?    Denk eraan: RED (1), GREEN (2), REFACTOR (3).\nOver het bijleren van programmeertalen https://brainbaking.com/post/2021/03/teaching-students-how-to-follow-development-trends/\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/patterns/facade/",
	"title": "5.1 Facade",
	"tags": [],
	"description": "",
	"content": "« Terug naar Software Engineering Skills » Naar de labo opgave\n\u0026ldquo;Facade\u0026rdquo; - Design Pattern Begeleidende screencast1:\n  Doelstelling  Scherm een complex stukje software af met behulp van een simpele interface Voorzie éénzelfde interface naar een set van verschillende mogelijke subsystemen. Een Facade is een high-level interface die mogelijks low-level systemen aanspreekt.  Dive Into Design Patterns: Facade\nVoorbeeld 1. Opzet Stel dat we gegevens van de klant moeten versturen naar een overheidsinstantie. Die instantie beschikt jammer genoeg niet over voldoende budgetten om ook een cutting-edge server interface en implementatie aan te bieden. Het komt er op neer dat we verplicht zijn om tekst bestanden op een FTP server te plaatsen.\nclass ClientFtpSender { fun upload(client: Client) { // create ftp connection, upload, ...  } } public class ClientFtpSender { public void upload(Client client) { // create ftp connection, upload, ...  } }  Deze code gebruiken we als de gebruiker op een knop genaamd export klikt:\nclass ClientHTTPHandler(val clientRepository: ClientRepository) { fun onExport(clientId: Int): HTTPResponse { val client = clientRepository.getById(clientId) ClientFtpSender().upload(client) return HTTPResponse.success() // 200 OK  } } public class ClientHTTPHandler { private ClientRepository clientRepository; public HTTPResponse onExport(int clientId) { Client client = clientRepository.getById(clientId); new ClientFtpSender().upload(client); return HTTPResponse.success(); // 200 OK  } }  mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A[HTTP Handler] B[FTP Sender] A -- B  2. Probleemstelling We verkopen onze software aan een andere partij, die niet alleen met de overheid wenst te communiceren, maar ook met een derde instantie. Deze instantie biedt ons de mogelijkheid aan om de klant in de vorm van XML met een POST HTTPS call op te sturen. Onze ClientFTPSender is dus niet meer genoeg:\nclass ClientPOSTSender { fun upload(client: Client) { // secure HTTPS, encode client in XML, post...  } } public class ClientPOSTSender { public void upload(Client client) { // secure HTTPS, encode client in XML, post...  } }  Deze complexe stukjes software, de POST en FTP senders, willen we niet langer rechtstreeks aanspreken in de HTTP handler. Het is zo dat afhankelijk van een bepaalde instelling, het ene of het andere gebruikt kan worden.\n3. Oplossing We hebben dus een facade nodig, die de juiste delegaties voor ons doorvoert, zoals in het volgende schema:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A[HTTP Handler] POST[POST Sender] FTP[FTP Sender] F{Facade} A -- F F -.- POST F -.- FTP  Waarbij de Facade een klasse is die de details \u0026ldquo;wegstopt\u0026rdquo; voor onze HTTP handler:\nclass UploadClientFacade { fun upload(client: Client) { when { settings.isPOST() -\u0026gt; ClientPOSTSender().upload(client) settings.isSFTP() -\u0026gt; ClientFtpSender().upload(client) else -\u0026gt; throw UnsupportedOperationException(\u0026#34;settings incorrect?\u0026#34;) } } } public class UploadClientFacade { public void upload(Client client) { if(settings.isPOST()) { new ClientPOSTSender().upload(client); } else if(settings.isFTP()) { new ClientFtpSender().upload(client); } else { throw new UnsupportedOperationException(\u0026#34;settings incorrect?\u0026#34;); } } }  Merk op dat in Kotlin de when { } block een heel krachtige manier is om selecties te maken. when is een expressie, geen statement: dat betekent dat je toekenningen kan doen, zoals val getal = when(someString) { \u0026quot;twee\u0026quot; -\u0026gt; 2 \u0026quot;drie\u0026quot; -\u0026gt; 3 else -\u0026gt; -1 }. Zie de control flow - when expression Kotlin docs voor meer informatie.  Om te begrijpen wat er gebeurt in de JVM kan je de Kotlin-compiled bytecode inspecteren via menu Tools - Kotlin - Show Kotlin Bytecode. Dit wordt in bytecode nog steeds vertaald naar een \u0026ldquo;simpele(re)\u0026rdquo; sequentie van Java if {} statements.\n Eigenschappen van dit patroon  Een Facade is een nieuwe interface, niet eentje die oude interfaces herbruikt (Adapter). Beide zijn een soort van \u0026ldquo;wrappers\u0026rdquo;, die onderliggende implementaties verbergen voor de hogerliggende interface - in ons geval de ClientHTTPHandler. Het verschil tussen een Facade en een Factory is dat de facade alles verbergt en logica uitvoert, terwijl de Factory enkel de juiste instanties aanmaakt en teruggeeft. In dat geval zou de handler nog steeds upload() zelf moeten uitvoeren, inclusief eventuele encoding stappen.  Labo oefeningen Via  Github Classroom.\nOpgave 1 Opgave tekst: zie GitHub classroom README.md bestand!\nOpgave 2 sessy library:\n identificeer waar jij denkt dat een facade nodig zou kunnen zijn. Waar moet logica worden afgeschermd? Pas het patroon toe waar jij denkt dat het nodig is.  Denkvragen  Op welk moment beslis je dat een Facade écht nodig is? Is het mogelijk om ook een facade te maken zonder bijvoorbeeld nieuwe dieren in oefening 1 of een nieuwe verzendmethode voor de klant bij de probleemstelling? Kan een Facade een Facade verbergen? Wanneer is dat nodig, of niet?    Merk op dat de cursus nu wordt gehost op https://kuleuven-diepenbeek.github.io/ses-course/ \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/patterns/di/",
	"title": "5.2 Dependency Injection",
	"tags": [],
	"description": "",
	"content": "\u0026ldquo;Dependency Injection (DI)\u0026quot; - Design Pattern Begeleidende screencast1:\n  Doelstelling  Promoot modulariteit door afhankelijkheden te injecteren, zodat aparte modules eenvoudig inplugbaar zijn in andere productiecode. Op deze manier worden modules ook makkelijker tesbaar. Promoot Inversion of Control: een client die services aanroept zou niet mogen weten hoe services worden aangemaakt - deze zou moeten worden \u0026lsquo;geinjecteerd\u0026rsquo;.  Wikipedia: Dependency Injection\nVoorbeeld 1. Opzet Als we verder gaan op het voorbeeld van de singleton, zien we dat een database handle nodig is om shopping cart gegevens op te halen. Hoe deze database wordt aangemaakt, daar heeft een typische API geen kaas van gegeten: daar komt meestal een connection string bij kijken met gebruikersnaam, wachtwoord, en IP adres naar de juiste DB server.\nDe DB accessor:\n// eigenlijk is dit al DI: de connectionString wordt meegegeven class DBHandle(val connectionString: String) { fun getShoppingCart(): ShoppingCart { // SELECT * FROM ...  } } public class DBHandle { private String connectionString; // eigenlijk is dit al DI: de connectionString wordt meegegeven  public DBHandle(String connectionString) { this.connectionString = connectionString; } public ShoppingCart getShoppingCart() { // SELECT * FROM ...  } }  Met als REST endpoint:\n@Path(\u0026#34;/shoppingcart\u0026#34;) class ShoppingResource { @GET fun getCart(): ShoppingCart { val conStr = ConfigurationManager.getConfig(\u0026#34;dbconnection\u0026#34;) return DBHandle(conStr).getShoppingCart() } } @Path(\u0026#34;/shoppingcart\u0026#34;) public class ShoppingResource { @GET public ShoppingCart getCart() { String conStr = ConfigurationManager.getConfig(\u0026#34;dbconnection\u0026#34;); return new DBHandle(conStr).getShoppingCart(); } }  2. Probleemstelling Elke Resource klasse die een DBHandle instance wenst, zal ook via de ConfigurationManager het constructor argument moeten ophalen, om een instantie te kunnen aanmaken. Dit is uiteraard niet de juiste manier en introduceert veel duplicatie. Nu is de shopping resource \u0026ldquo;in control\u0026rdquo;, terwijl we in dat geval de Database de controle willen geven: Inversion of Control dus.\n3. Oplossing Een mogelijke oplossing is een Singleton maken: zie het Singleton pattern. Maar dan hebben we nog steeds:\n@Path(\u0026#34;/shoppingcart\u0026#34;) class ShoppingResource { @GET fun getCart(): ShoppingCart { return DBHandle.getShoppingCart() } } @Path(\u0026#34;/shoppingcart\u0026#34;) public class ShoppingResource { @GET public ShoppingCart getCart() { return DBHandle.getInstance().getShoppingCart(); } }  Als we deze methode willen unit testen, door getCart() op te roepen, spreken we steeds de échte database aan, wat duidelijk niet het gewenste gedrag is. We willen in dat geval de database injecteren. Een tweede stap is om de implementatie te verbergen achter een interface.\n@Path(\u0026#34;/shoppingcart\u0026#34;) class ShoppingResource(val dbHandle: DBHandle) { @GET fun getCart(): ShoppingCart { return dbHandle.getShoppingCart() } } @Path(\u0026#34;/shoppingcart\u0026#34;) public class ShoppingResource { private final DBHandle dbHandle; public ShoppingResource(DBHandle handle) { this.dbHandle = handle; } @GET public ShoppingCart getCart() { return dbHandle.getShoppingCart(); } }  Merk op dat de Kotlin implementatie veel korter is dankzij primary constructors: alles tussen de haakjes wordt automatisch omgezet in een veld dat injecteerbaar is. Bijkomend, val is automatisch een final veld. Om te begrijpen wat er gebeurt in de JVM kan je de Kotlin-compiled bytecode inspecteren via menu Tools - Kotlin - Show Kotlin Bytecode.\n Nu weet deze klasse niet meer hoe hij de database aanmaakt: hij krijgt dit slechts toegeschoven via de constructor. Uiteraard hebben we het probleem verlegt: wie maakt deze resource klasse aan? Om dit probleem op te lossen zijn er typische Dependency Injection frameworks beschikbaar die objecten in een pool aanmaken en zo injecteren. Voorbeelden hiervan zijn:\n Google Guice Google Dagger (vooral, maar niet alleen, voor Android development) Spring Framework Kodein-DI (vooral, maar niet alleen, voor Kotlin projecten)  Als DBHandle een interface is, kunnen we op een eenvoudige manier een dummy implementatie maken en dit injecteren in de klasse ter test:\nclass DummyDBHandle : DBHandle { var called = false override fun getShoppingCart(): ShoppingCart? { called = true return null } } class ShoppingResourceTest { @Test fun getCart_callsGetShoppingCartFromDb() { val dbHandle = DummyDBHandle() // hier \u0026#34;injecteren\u0026#34; we de dbHandle dummy in de ShoppingResource.  val resource = ShoppingResource(dbHandle) resource.getCart() assertThat(dbHandle.called, Is(true)) } } public class DummyDBHandle implements DBHandle { public boolean called; @Override public ShoppingCart getShoppingCart() { called = true; return null; } } public class ShoppingResourceTest { @Test public void getCart_callsGetShoppingCartFromDb() { DummyDBHandle dbHandle = new DummyDBHandle(); // hier \u0026#34;injecteren\u0026#34; we de dbHandle dummy in de ShoppingResource.  ShoppingResource resource = new ShoppingResource(dbHandle); resource.getCart(); assertThat(dbHandle.called, is(true)); } }  Merk op dat de connectionString van de DBHandle ook via de constructor als argument wordt doorgegeven: dit is evenzeer een vorm van Dependency Injection.\nEigenschappen van dit patroon  Geef de verantwoordelijkheid van het aanmaken van een object af. Een instantie wordt geinjecteerd door middel van een constructor of setter. Maak van objecten geïsoleerde(re) stukjes code die makkelijker testbaar zijn dan hard gekoppelde objecten.  Labo oefeningen Via  Github Classroom.\nOpgave 1  Er staan twee TODO items: verwijder eerst de new DBHandle() vanuit de resource klasse, en injecteer het via een constructor argument. Pas dan de unit test aan om de compile fouten te fixen. Gebruik een interface om bovenstaande DummyDBHandle in het project te introduceren. Dat wil zeggen, hernoem DBHandle naar DBHandleImplementation, en maak een nieuwe interface genaamd DBHandle. Nu kan je de tweede unit test zoals hierboven toevoegen.  Opgave 2 In plaats van manueel te injecteren, kunnen we deze zaken ook overlaten aan gespecialiseerde frameworks, zoals Google Guice. Bovenstaand project heeft als Gradle dependency een link naar Guice. Neem een kijkje in de ShoppingCartGuiceResource klasse, en probeer dit principe toe te passen op de andere resouce klasse. @Inject verzogt het DI systeem, zonder zelf ergens objecten aan te maken, behalve in de config klasse.\nZie ook Google Guice: getting started.\nOpgave 3 sessy library:\n Welke klassen worden reeds geïnjecteerd, en op welke manier? (Constructor injectie, setter injectie, \u0026hellip;) identificeer welke klassen in een DI systeem kunnen worden opgenomen. Introduceer een DI systeem: hetzij door Google Guice te gebruiken, hetzij door zelf te injecteren. Waar wordt DI reeds toegepast?  Denkvragen  Dependency Injection kan via de constructor, via setters (of direct op het veld via reflectie). Wat zijn de voor- en nadelen van via de constructor te werken, ten opzichte van via setters? Denk je dat de GuiceConfigModule klasse op termijn niet te groot en verwarrend wordt, als dit constant wordt uitgebreid met nieuwe instanties die geregistreerd worden bij Guice? Wat zou je dan doen om dit tegen te gaan?    Merk op dat de cursus nu wordt gehost op https://kuleuven-diepenbeek.github.io/ses-course/ \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/patterns/singleton/",
	"title": "5.3 Singleton",
	"tags": [],
	"description": "",
	"content": "\u0026ldquo;Singleton\u0026rdquo; - Design Pattern Begeleidende screencast1:\n  Doelstelling  Vermijd de mogelijkheid tot meervoudige instantiatie van een bepaalde klasse. Er kan altijd maar één bepaalde instantie van bestaan. Voorzie een eenvoudige manier om vanuit eender waar in de code toegang te verkrijgen tot die éne instantie. Encapsuleer logica om deze instantie aan te maken, moest code dit raadplegen en dit toevallig de eerste keer zijn (lazy initialization).  Dive Into Design Patterns: Singleton\nVoorbeeld 1. Opzet Een klassiek voorbeeld van een Singleton patroon is een database connectie, omdat het beheren van diezelfde connecties door diezelfde klasse gebeurt. Stel dat we een website hebben gemaakt met een winkelwagentje.\ndata class ShoppingCart(val amountOfItems: int, val totalMoney: int) public class ShoppingCart { private int amountOfItems; // and getters/setters  private int totalMoney; // ... }  En de DB accessor:\nclass DBHandle { fun getShoppingCart(): ShoppingCart { // SELECT * FROM ...  } } public class DBHandle { public ShoppingCart getShoppingCart() { // SELECT * FROM ...  } }  Met als REST endpoint:\n@Path(\u0026#34;/shoppingcart\u0026#34;) class ShoppingResource { @GET fun getCart(): ShoppingCart { return DBHandle().getShoppingCart() // oops!  } } @Path(\u0026#34;/shoppingcart\u0026#34;) public class ShoppingResource { @GET public ShoppingCart getCart() { return new DBHandle().getShoppingCart(); // oops!  } }  2. Probleemstelling Tien gebruikers die op de site terecht komen wensen allemaal hun winkelwagentje te raadplegen. Er zijn maar twee DB connecties beschikbaar, dit opgelegd door de database zelf. Iemand moet die dus beheren (locken, vrijgeven, locken, \u0026hellip; - dit heet database pooling).\nAls we twee instanties van DBHandle maken, kunnen er plots 2x2 connecties open worden gemaakt naar de database. Die zal dit ook blokkeren, wat resulteert in 2 klanten die een crash ervaren, en twee die hun winkelwagen kunnen raadplegen zonder verdere problemen.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[ShoppingResource Inst1] B[ShoppingResource Inst2] C[DBHandle Inst1] D[DBHandle Inst2] A --|nieuwe instance| C B --|nieuwe instance| D  De getCart() methode mag dus in geen geval telkens een nieuwe DBHandle aanmaken.\n3. Oplossing We hebben in dit geval een singleton instance nodig:\n@Path(\u0026#34;/shoppingcart\u0026#34;) class ShoppingResource { @GET fun getCart(): ShoppingCart { return DBHandle.getShoppingCart() } } @Path(\u0026#34;/shoppingcart\u0026#34;) public class ShoppingResource { @GET public ShoppingCart getCart() { return DBHandle.getInstance().getShoppingCart(); } }  Waarbij de klasse DBHandle wordt uitgebreid tot:\nobject DBHandle { fun getShoppingCart(): ShoppingCart { // SELECT * FROM ...  } } public class DBHandle { private static DBHandle instance; public static DBHandle getInstance() { if(instance == null) { instance = new DBHandle(); } return instance; } private DBHandle() { } public ShoppingCart getShoppingCart() { // SELECT * FROM ...  } }  Merk op dat Kotlin ingebouwde features heeft voor singleton: namelijk het object keyword dat class vervangt in bovenstaande code. Dit is véél meer werk in Java. De \u0026ldquo;Java way\u0026rdquo; moet ook gekend zijn! Bijkomend, Kotlin heeft geen static keyword.  Om te begrijpen wat er gebeurt in de JVM kan je de Kotlin-compiled bytecode inspecteren via menu Tools - Kotlin - Show Kotlin Bytecode. Een object bevat automatisch een statische referentie naar zichzelf, zoals we in Java handmatig moeten schrijven: public static final DBHandle INSTANCE;. Calls naar Kotlin\u0026rsquo;s DBHandle.getShoppingCart() worden automatisch vervangen door Java\u0026rsquo;s DBHandle.INSTANCE.getShoppingCart();\n mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[ShoppingResource Inst1] B[ShoppingResource Inst2] C[DBHandle Inst] A --|zelfde instance| C B --|zelfde instance| C  Op die manier is het aanmaken van een DBHandle instance beperkt tot de klasse zelf, door de private constructor. In de statische methode wordt er eerst gecontroleerd of de instantie null is of niet. In principe zou er maar één keer tijdens de uitvoering van het programma de new DBHandle() regel worden uitgevoerd2.\nEigenschappen van dit patroon  Definiëer de enige instantie als een ontoegankelijke static variabele, die door één enkele public static methode wordt bewaakt. Singleton klassen hebben enkel een private constructor om te voorkomen dat dit nog elders kan worden aangemaakt. Er wordt meestal een null check gedaan, zodat de code die de getter aanroept dit niet opnieuw moet doen. Dit voorkomt onnodige duplicatie op verschillende plaatsen in de codebase.  Labo oefeningen Via  Github Classroom.\nOpgave 1 Hierin is bovenstaande voorbeeld verwerkt, maar nog zonder Singleton\u0026hellip; Voer de unit testen uit in src/main/test: het resultaat zijn gefaalde testen (ROOD), omdat DBHandle verschillende keren wordt aangemaakt. Zorg er voor dat alle testen slagen (GROEN) door het singleton patroon te implementeren!\nOpgave 2 Pas ook ShoppingCartResource aan naar een singleton. Is dat nodig om de database niet te overbelasten, als de andere klasse reeds een singleton is, of niet?\nOpgave 3 sessy library:\n identificeer welke klassen een kans maken om een Singleton te worden. Denk aan bovenstaande voorbeeld. Is er reeds ergens een Singleton patroon geïmplementeerd? Pas het patroon toe waar jij denkt dat het nodig is. Hoe kan je afleiden welke gebruikte frameworks op bepaalde plekken Singleton klasses hebben?  Denkvragen  Dit patroon klinkt aanlokkelijk: eenvoudig, lost problemen op, dus waarom niet overal toepassen. Denk eens na over de verantwoordelijkheden van objecten. Waarom zou je zo veel mogelijk moeten vermijden om dit patroon toe te passen? Wie mag wel DBHandle.getInstance() (of in geval van Kotlin, de functies zelf) aanroepen, en wie niet? Wat gebeurt er als 10 mensen tegelijkertijd de eerste keer de getInstance() methode aanroepen? Hoe kunnen we dit oplossen?    Merk op dat de cursus nu wordt gehost op https://kuleuven-diepenbeek.github.io/ses-course/ \u0026#x21a9;\u0026#xfe0e;\n Dit klopt niet helemaal als we kijken naar concurrency problemen, waarbij twee gebruikers op exact hetzelfde tijdstip de methode aanroepen. Dit laten we buiten beschouwing voor dit vak. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/patterns/decorator/",
	"title": "5.4 Decorator",
	"tags": [],
	"description": "",
	"content": "\u0026ldquo;Decorator\u0026rdquo; - Design Pattern Begeleidende screencast1:\n  Doelstelling  Voeg dynamisch functionaliteit toe als alternatief voor klassieke overerving. Gedraagt zich zoals het stukje \u0026lsquo;ingepakte\u0026rsquo; functionaliteit, maar voert extra handelingen uit. Wordt in Java altijd via interface implementaties uitegevoerd.  Dive Into Design Patterns: Decorator\nVoorbeeld 1. Opzet Stel dat we in een fabriek op plaats X een auto samenstellen. De wagen is een zeer eenvoudige Volkswagen Golf, zonder opties. Op een andere locatie, plaats Y, hebben wij als bedrijf ook fabrieken die sportauto\u0026rsquo;s bouwen (Volkswagen Scirocco) en op plaats Z luxe wagens (Volkswagen Passat).\ninterface Car { fun assemble() // build stuff } public interface Car { public void assemble(); // build stuff }  Fabriek X:\nclass VWGolf : Car { override fun assemble() = println(\u0026#34;do not forget the steering wheel!\u0026#34;) } public class VWGolf implements Car { @Override public void assemble() { System.out.println(\u0026#34;do not forget the steering wheel!\u0026#34;); } }  Fabriek Y:\nclass VWScirocco : Car { override fun assemble() = println(\u0026#34;do not forget lots of turbo!\u0026#34;) } public class VWScirocco implements Car { @Override public void assemble() { System.out.println(\u0026#34;do not forget lots of turbo!\u0026#34;); } }  Fabriek Z:\nclass VWPassat : Car { override fun assemble() = println(\u0026#34;do not forget all the leather!\u0026#34;) } public class VWPassat implements Car { @Override public void assemble() { System.out.println(\u0026#34;do not forget all the leather!\u0026#34;); } }  mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[\"VW Golf\"] B[\"VW Scirocco\"] C[\"VW Passat\"] Z{Car} Z -- A Z -- B Z -- C  2. Probleemstelling De General Manager belt: hij meldt ons vrolijk dat we zijn opgekocht door Geely, een Chinese autofabriekant. De heren in China wensen een mooie combinatie te maken tussen langs de ene kant luxe, en langs de andere kant pure kracht. Een combinatie van de technologie van fabriek Y en Z, dus. Dit mag enkel op aanvraag gebeuren, en is dus niet simpelweg een nieuwe variant van een VW assemblage, maar een dynamische combinatie, waarbij soms meer luxe en soms meer kracht wordt gevraagd. Dat hangt natuurlijk van de klant af.\nWe zullen dus een custom optie voorzien:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[\"VW Golf\"] B[\"VW Scirocco\"] C[\"VW Passat\"] D[\"Custom Car Decorator\"] Z{Car} Z -- A Z -- B Z -- C B -- D C -- D  3. Oplossing Deze custom oplossing is nog steeds een implementatie van de interface Car:\nclass CustomCarDecorator : Car { val carsToAssemble: List\u0026lt;Car\u0026gt; constructor(vararg carTypes: Car) { carsToAssemble = carTypes.toList() } override fun assemble() { for(car in carsToAssemble) { car.assemble() } } } public class CustomCarDecorator implements Car { private final List\u0026lt;Car\u0026gt; carsToAssemble; public CustomCarDecorator(Car... carTypes) { this.carsToAssemble = Arrays.asList(carTypes); } @Override public void assemble() { for(Car car : carsToAssemble) { car.assemble(); } } }  Op deze manier kunnen we zoveel auto types als de klant wenst doorgeven aan de CustomCarDecorator instantie, die netjes in de bestaande fabriek logica past, gegeven de volgende fabriek klasse:\nclass Factory { fun create(car: Car): Car { car.assemble() // works, since it\u0026#39;s an interface  paint(car) return car } private fun paint(car: Car) = println(\u0026#34;painting...\u0026#34;) } public class Factory { public Car create(Car car) { car.assemble(); // works, since it\u0026#39;s an interface  paint(car); return car; } private void paint(Car car) { System.out.println(\u0026#34;painting...\u0026#34;); } }  Dit werkt enkel en alleen omdat we met een interface werken!\nEigenschappen van dit patroon  Een Decorator verandert het contract van de interface niet. De interface wordt uitgebreid, zijnde dat bovenstaande CustomCarDecorator extra dingen doet ten opzichte van de standaard VW Golf/andere implementaties. Een Decorator kan je gebruiken om extra functionaliteiten toe te voegen zonder aan de klasse structuur grote wijzigingen door te voeren. Gebruik hiervoor, zoals de List\u0026lt;Car\u0026gt; carsToAssemble member variable, Compositie, en niet Inheritance. Een Decorator verandert de flow van de functionaliteit niet: dat doet een Strategy - een decorator voorziet enkel een ander uitzicht. Denk aan een doos in een doos stoppen: daar kan ook stiekem nog een extra doos in worden geplaatst. Maar het blijven dozen.  Labo oefeningen Via  Github Classroom.\nOpgave 1 Dit bevat bovenstaande wagenpark voorbeeld. Hier dien je de volgende dingen nog aan te wijzigen:\n Voorzie in de main() methode een nieuwe decorator instantie en geef die mee met de factory. Kijk in de output wat er gebeurt. Maak een nieuwe auto implementatie aan, VWPolo. Geef de decorator een Golf en Polo mee. Nu maken we plots iets hoger niveau budget wagens! Voorzie een eigen, statische decorator klasse, genaamd PoloGolfDecorator, die altijd bovenstaande wagens (Polo en Golf) combineert. Wat zit er in de klasse? Hoe implementeer je assemble()?  Opgave 2 Werk verder op opgave 1: bouw een nieuwe Factory in Zweden. Deze Factory in Zweden kan veel meer kleuren op het chassis spuiten dan de klassieke Factory. (Verzin iets anders in het println() statement). Wat als een klant een combinatie van deze factory, en de klassieke wenst? Maak een Decorator voor de factories in plaats van de wagens. Test deze in de Main klasse.\nOpgave 3 sessy library:\n identificeer waar jij denkt dat een decorator nodig zou kunnen zijn. Waar zou mogelijks dynamische logica gebruikt kunnen worden? Pas het patroon toe waar jij denkt dat het nodig is.  Denkvragen  Stel dat de klant altijd een combinatie van twee bepaalde auto\u0026rsquo;s wenst. Wanneer beslissen we om dit permanent op te nemen in ons repertroire, en er een \u0026ldquo;echte\u0026rdquo; subklasse van te maken, en wanneer houden we het nog op een decorator? Op welk patroon trekt dit patroon nog? Waarom? Zie [/](labo noties index) pagina. Kan je dit ook zonder interfaces doen? Denk na over implementaties in andere programmeertalen.    Merk op dat de cursus nu wordt gehost op https://kuleuven-diepenbeek.github.io/ses-course/ \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/patterns/factory/",
	"title": "5.5 Factory",
	"tags": [],
	"description": "",
	"content": "\u0026ldquo;Factory\u0026rdquo; - Design Pattern Begeleidende screencast1:\n  Doelstelling  Scherm het aanmaken van bepaalde objecten af door middel van overerving en logica, waarbij die logica éénmalig wordt geïmplementeerd, en op een centrale plaats staat. Promoot een modulair model door de verantwoordlijkheid van object creatie en object gebruik te scheiden.  Dive Into Design Patterns: Factory (method)\nVoorbeeld 1. Opzet Stel, je wilt aan de kassa van een niet al te grote lokale cinema een film kopen. Stel, de persoon aan de kassa beslist de film, gebaseerd op je leeftijd. Er spelen die avond drie filmen: een kindvriendelijke, eentje voor tieners, en eentje gereserveerd voor volwassenen.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A{Ticket} B[FamilyFilm] C[TeenageFilm] D[XRatedFilm] E[TicketSeller] F[Person] A -- B A -- C A -- D  Waarbij een persoon een bepaalde leeftijd heeft:\ndata class Person(val age: int) public class Person { private final int age; public int getAge() { return age; } public Person(int age) { this.age = age; } }  En de ticket verkoper een ticket verkoopt aan een persoon:\nclass TicketSeller { fun buyTicketFor(person: Person): Ticket? { return null } } public class TicketSeller { Ticket buyTicketFor(Person person) { return null; } }  2. Probleemstelling De logica voor het aanmaken van de juiste Ticket subklasse moet op één centrale plaats staan. De ticket verkoper is hier ideaal voor, waarbij met wat simpele logica gebaseerd op person.getAge() de juiste film kan worden aangemaakt. We noemen in dat geval de methode buyTicketFor() een factory method.\n3. Oplossing Door te controleren op leeftijd kan men de juiste instantie aanmaken en teruggeven. Dit is de verantwoordelijkheid van de ticket seller. Het voordeel is dat je als \u0026ldquo;gebruiker\u0026rdquo; van deze klasse, die de methode buyTicketFor() aanroept, je niet hoeft af te vragen wat er achter de abstracte klasse Ticket zit. Het is een ticket, de code kan verder lopen.\nWe kunnen dit nog verder drijven door de ticket verkoper zelf ook te laten aanmaken door een \u0026ldquo;factory\u0026rdquo; die bijvoorbeeld de medewerkers van diezelfde lokale cinema inhuurt. Persoon x verkoopt je tickets op basis van je leeftijd, en persoon y op basis van hoeveel geld je op zak hebt.\nEigenschappen van dit patroon  Implementaties (van Ticket) zijn verborgen via de Factory Method. Logica voor creatie staat op één centrale plaats.  Labo oefeningen Via  Github Classroom.\nOpgave 1 Het project bevat bovenstaande voorbeeld, maar nog niet alles is geïmplementeerd. Voer de unit testen uit in src/main/test: het resultaat zijn gefaalde testen (ROOD). Zorg er voor dat alle testen slagen (GROEN) door het factory patroon te vervolledigen!\nOpgave 2 De eerste aanzet is genomen om een nieuw type van TicketSeller aan te maken, door reeds een interface te voorzien. Ontwikkel een MoneyBasedTicketSeller, die gebaseerd op het geld in je portefuille je het juiste ticket bezorgt. Dit betekent dat je in Person dus een nieuwe property nodig hebt. Voorzie ook een nieuwe test klasse, gebaseerd op AgeBasedTicketSellerTest.\nOpgave 3 sessy library:\n identificeer waar het mogelijk zou zijn om een factory patroon toe te passen. Welke verschillende implementaties delen een gelijke noemer? Waar staat mogelijks creatie logica (dubbel)? Pas dit toe door een nieuwe klasse te voorzien die de Factory methode implementeert. Vergeet de unit testen niet!  mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A{Ticket} B[FamilyFilm] C[TeenageFilm] D[XRatedFilm] E{TicketSeller} F[AgeBasedTicketSeller] G[MoneyBasedTicketSeller] A -- B A -- C A -- D E -- F E -- G  Denkvragen  Wat is het verschil tussen een factory en een facade patroon? Wanneer heb ik het ene of het andere nodig? Is er een mogelijkheid om Dependency Injection en de Factory te combineren, zodat het keyword new niet meer wordt gebruikt in de factory klasse zelf?    Merk op dat de cursus nu wordt gehost op https://kuleuven-diepenbeek.github.io/ses-course/ \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/lifecycle/ci/",
	"title": "6.1 Continuous Integration &amp; Deployment",
	"tags": [],
	"description": "",
	"content": "Begeleidende screencast:\n  1. Continuous Integration (CI) Het softwareontwikkel proces is een continu proces: als een eerste versie van het product klaar is, en wordt overgemaakt aan klanten, volgt het onderhoud en een mogelijke volgende versie. Elke wijziging maakt potentiëel dingen kapot (geminimaliseerd met TDD), of introduceert nieuwe features. Dat betekent dat bij elke wijziging, een computer het hele build proces moet doorlopen om te controleren of er niets stuk is. Dit noemen we het \u0026ldquo;integreren\u0026rdquo; van nieuwe code, vandaar de naam.\n1.1. De CI Server In de praktijk worden aparte servers verantwoordelijk gesteld om regelmatig de hele codebase te downloaden, alles te compileren, en testen uit te voeren. Als iets niet compileert, of een test faalt, rapporteert dit systeem via diverse kanalen aan de ontwikkelaars. Niemand wilt dit in de achtergrond op zijn eigen machine een tweede build systeem geïnstalleerd hebben, die CPU kracht afsnoept van je eigen IDE. De volgende Figuur verduidelijkt de flow (bron):\n  Het Continuous Integration build systeem  Dit hele proces verloopt volledig automatisch: niemand drukt op een \u0026ldquo;build\u0026rdquo; knop, maar door middel van ingecheckte code wijzigingen (1) start dit systeem. De CI server haalt wijzigingen op (2), build (3) en test (4) om te kunnen rapporteren of dit lukte of niet (5), via verschillende kanalen (6).\nDe Source Control server, zoals Github.com of een lokale git server, werd reeds besproken in labo \u0026lsquo;versiebeheer\u0026rsquo;. Er zijn voor Java verschillende populaire CI software systemen:\n Jenkins TeamCity Bamboo Travis  In deze systemen zijn configureerbaar en beschikken over een UI, zoals bijvoorbeeld zichtbaar in de TeamCity screencast. Betalende systemen zoals TeamCity en Bamboo zijn erg uitgebreid, maar wij gaan werken met Travis. Travis CI is eenvoudig configureerbaar door middel van een .yml bestand en integreert naadloos (en gratis) met Github.\n1.2. De flow van een CI server De SESsy library git repository bevat een .travis.yml bestand dat de Travis server instrueert wat te doen op welk moment:\n language: java jdk: - openjdk11 env: - NODE_VERSION=\"12.10.0\" notifications: email: false before_install: - nvm install $NODE_VERSION - nvm use $NODE_VERSION - pushd frontend - npm install - mkdir dist - popd install: - ./gradlew check - ./gradlew frontendSync --stacktrace - ./gradlew shadowJar  1. Checkout Code git clone [repository] (met de juiste branch). Klaar.\n2. Setup Environment Elke build op Travis begint met een clean besturingssysteem (standaard Linux) en gegeven basistools. Dat betekent dat als bepaalde versies van node of Java nodig zijn, deze eerst moeten worden geïnstalleerd. Travis voorziet openJDK versies - de Oracle versies moeten zelf worden afgehaald. Voor SESsy library is ook node vereist die de frontend kan builden.\nIn before_install plaats je uit te voeren instructies die voor de install stap worden uitgevoerd.\n3. Build Code Gebruik Gradle Tasks:\n check - installeert de juiste Gradle versie, compileert en test. frontendSync - build met node de frontend en kopiëert naar src/main/resources.  4. Test Code Deel van ./gradlew check.\n5. Package Code \u0026amp; Upload Artifact ./gradlew shadowJar - package alles, inclusief dependencies, in één grote jarfile.\nZodra één stap mis gaat (zoals een falende test), worden volgende stappen niet uitgevoerd. Als alles goed gaat is de output van het builden de binary die we het artifact noemen, die de huidige buildstamp draagt (meestal een datumcode).\nAlle gebuilde artifacts kunnen daarna worden geupload naar een repository server, zoals de Central Maven Repository, of onze eigen artifact server, waar een historiek wordt bijgehouden.\n6. Publish Results Op hat dashboard van https://travis-ci.org kan je de gepubliceerde resultaten (live) raadplegen:\n   2. Continuous Deployment (CD) Automatisch code compileren, testen, en packagen, is slechts één stap in het continuous development proces. De volgende stap is deze package ook automatisch deployen, of installeren. Op deze manier staat er altijd de laatste versie op een interne development website, kunnen installaties automatisch worden uitgevoerd op bepaalde tijdstippen, \u0026hellip;\nPopulaire CD systemen:\n Octopus Deploy Codeship Eigen scripts gebaseerd op CI systemen Cloud deployment systemen (Amazon AWS, Heroku, Google Apps, \u0026hellip;)  De shadowJar task genereert één jar bestand die uitvoerbaar is (java -jar [filename].jar), en onze DropWizard server lokaal opstart op poort 8000. Eender welke server kan dit programma dus op eenvoudige wijze uitvoeren.\nAutomatisch packagen en installeren van programma\u0026rsquo;s stopt hier niet. Een niveau hoger is het automatisch packagen en installeren van hele omgevingen: het virtualiseren van een server. Infrastructuur automatisatie is een vak apart, en wordt vaak uitgevoerd met behulp van tools als Puppet, Docker, Terraform, Ansible of Chef. Dit valt buiten de scope van deze cursus.\n2.1. De flow van deployment en releases beheren Nieuwe features in productie plaatsen brengt altijd een risico met zich mee. Het zou kunnen dat bepaalde nieuwe features bugs veroorzaken in de gekende oude features, of dat het (slecht getest) systeem helemaal niet werkt zoals men verwachtte. Om dat zo veel mogelijk te vermijden wordt er een release plan opgesteld waarin men aan \u0026lsquo;smart routing\u0026rsquo; doet.\nStel, onze SESsy bibliotheek webapplicatie is toe aan vernieuwing. We wensen een nieuw scherm te ontwerpen om efficiënter te zoeken. We zijn echter niet zeker wat de gebruikers gaan vinden van deze nieuwe manier van werken, en beslissen daarom om slechts een aantal gebruikers bloot te stellen aan deze radicale verandering. Dat kan op twee manieren:\n Blue/green releasing: Een \u0026lsquo;harde switch\u0026rsquo; in het systeem bepaalt welke personen (bijvoorbeeld op regio of IP) naar versie van het zoekscherm worden begeleid. Canary releasing: Een load balancer verdeelt het netwerkverkeer over verschillende servers, waarvan op één server de nieuwe versie is geïnstalleerd. In het begin gaat 90% van de bezoekers nog steeds naar de oude versie. Dit kan gradueel worden verhoogd, totdat de oude server wordt uitgeschakeld.  Onderstaand schema verduidelijkt dit idee (bron).\n   De juiste logging en monitoring tools zorgen ervoor dat we een idee krijgen over het gebruik van het nieuwe scherm (groen, versie B). Gaat alles zoals verwacht, dan wordt de switch weggehaald in geval (1), of wordt de loadbalancer ge-herconfigureerd zodat het hele verkeer naar de nieuwe site gaat in geval (2). Ook deze aanpassingen zijn volledig geautomatiseerd. Na verloop van tijd valt de oude versie (blauw, versie A) volledig weg, en kunnen we ons concentreren op de volgende uitbreidingen.\nHet groene vlak, de \u0026lsquo;Ambassador/API gateway\u0026rsquo;, kan aanzien worden als:\n Een fysiek aparte machine, zoals een loadbalancer. Een publieke API, die de juiste redirects verzorgt. Een switch in de code, die binnen dezelfde toepassing naar scherm 1 of 2 verwijst.  Versie A en B hoeven dus niet noodzakelijk aparte versies van applicaties te zijn: dit kan binnen dezelfde applicatie, softwarematig dus, worden ingebouwd.\nLabo oefeningen Opgave 1 Omwille van privacy instellingen tussen Travis en de KULeuven-Diepenbeek organisatie op Github, wordt voor deze opgave verwacht dat je een nieuwe repository zelf aanmaakt vanaf nul, via Github.com. Geef de repository de naam ses-ci-opgave, zoals in onderstaande screenshot:\n   Het is belangrijk dat de repository public is, anders kan Travis je project niet builden.\n1.1 De Calculator app Ontwerp een command-line interface programma, getiteld \u0026lsquo;calculator\u0026rsquo;, dat twee argumenten inleest die terecht komen in de main() methode, en de sommatie ervan afdrukt:\njava -cp . Calculator 1 4 print 5 in stdout.\nUiteraard gebruiken we hier Gradle voor. Zet de berekening in een aparte methode, die ook getest werd. Voorzie dus ook Enkele eenvoudige unit testen in src/main/test.\n1.2 De app builden op Travis Nadat de code voor 1.1 werd gecommit en gepushed op je Git repository, is de volgende stap dit project automatisch te builden op een server, zoals Travis. Om dit te activeren moeten er twee stappen worden uitgevoerd:\n Activeer je repository door op travis-ci.org in te loggen met je Github account, de repository terug te zoeken in de lijst door op + te drukken links, en de slider naar rechts te zetten, zodat Travis changes detecteert. Zie screenshot hieronder. Voorzie een .travis.yml bestand waarin staat beschreven op welke manier je project moet worden gebuild.     Het verschil tussen de .org en .com websites is dat de eerste enkel publieke repositories kan behandelen, terwijl de laatste (in BETA) ook private repositories aankan. Vergewis je ervan om enkel via de eerste, travis-ci.org, je opgave repository te activeren.\nWelke stappen denk je dat Travis zou moeten ondernemen op je project te builden? Is enkel builden voldoende? Wat als er een test faalt? Stel dat we de gebuilde jar ergens willen uploaden, hoe gaan we dan tewerk? Raadpleeg de documentatie om jezelf te bekwamen in de Yaml syntax:\n Customizing the build - Travis Building a Java Project - Travis  Opgave 2 Er duikt plots een onvoorziene periode van boekenschaarste op! Om niet te veel paniek te veroorzaken, willen we gebruik maken van blue/green releasing om het uitleensysteem van SESsy library gradueel te wijzigen.\nDe klasse BorrowBooksResource is het entry point voor alle calls naar /borrow, zoals de @Path annotatie aanduidt. Deze klasse zal voortaan moeten dienen als API gateway die gebruikers omleidt, ofwel naar het gebruikelijke uitleenproces, ofwel naar een methode die niet meer toestaat dat boeken worden uitgeleend, onafhankelijk van de ingelogde gebruiker of het type boek.\nMaak twee nieuwe klasses aan, BorrowBooksOriginalResource (1) met de originele borrow() implementatie, en BorrowBooksNotAllowedResource (2), die altijd een status FORBIDDEN teruggeeft. Kennis van patterns is een pluspunt hier.\nDenk na over hoe je de bestaande klasse BorrowBooksResource gaat aanpassen om bepaalde gebruikers naar ofwel (1) ofwel (2) te leiden. Je kan bijvoorbeeld een aantal boeken (op basis van ISBN) wel of niet toestaan, of gebaseerd op de sessie een aantal gebruikers wel of niet toestaan. Neem een kijkje in request.getSession(): wat is bruikbaar, en wat niet?\nDenkvragen  Waarom is het belangrijk om gebuilde artifacts van de CI server bij te houden? Wat zijn de voordelen van het werken met een CI en CD systeem, ten opzichte van alles met de hand (of met eigen gemaakte scripts) in te stellen? Version control en continuous delivery zijn klassiek gezien vijanden van database migratie (of omgekeerd). Toch is het mogelijk om een database systeem ook automatisch te up- of downgraden, met bijvoorbeeld https://flywaydb.org. Hoe gaat zoiets in zijn werk?  Extra Leermateriaal  Martin Fowler on Continuous Integration Martin Fowler on Canary Releases Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/lifecycle/management/",
	"title": "6.2 Software Management Skills",
	"tags": [],
	"description": "",
	"content": "De chaos van het Werk De technische kant van het ontwikkelproces is slechts één kant van de medaille. De keerzijde bestaat uit het werk beheren en beheersen, zonder ten prooi te vallen aan de grillen van de klant of de chaos van de organisatie ervan.\nStel, een gemeente vraagt om een nieuwe website te ontwikkelen voor de lokale bibliotheek. Er wordt een vergadering ingepland met stafhouders om samen met jou te beslissen wat de vereisten zijn. Ze dachten aan een mooie visuele website (1) waar men ook on-line kan verlengen (2) en het profiel raadplegen (3). De website moet uiteraard de gebruiker laten weten of een boek is uitgeleend of niet (4), en nieuwe aanwisten verdienen een aparte pagina (5). Men wil kunnen inloggen met de eID (6), én met een speciale bibkaart (7). Een bezoek aan de bib zelf levert je nog meer eisen op: het personeel wilt immers de nadruk leggen op andere zaken dan de stafhouders.\nHoe ga je te werk om dit te beheren en tot een succesvol einde te brengen? Er is een raamwerk nodig om:\n Werk overzichtelijk in kaart te brengen Werk in te schatten en op te delen in beheersbare deeltaken Werk eenvoudig te kunnen verdelen Werk zichtbaar te maken: wie met wat bezig is, wanneer het klaar is, \u0026hellip; De klant in elke stap van het proces zo nauw mogelijk te betrekken  A. Werk managen: Scrum De alsmaar populair wordende term \u0026lsquo;scrum\u0026rsquo; komt vanuit de Amerikaanse sport rugby, waar men letterlijk de koppen bij elkaar steekt om nog een laatste peptalk uit te delen voordat de chaos van de wedstrijd zelf losbarst (Bron):\n  Een \u0026#39;Scrum\u0026#39; bespreking  Het principe van deze coördinatie is gemuteerd naar de softwareontwikkeling, waar het Scrum framework een oplossing kan bieden voor ons beheer probleem, waarvan alle 5 bovenstaande punten van het probleem op een structurele manier worden aangepakt.\nEen Werk \u0026lsquo;raamwerk\u0026rsquo; Een agile software development methodologie is een methodologie om snel te kunnen ingrijpen op veranderingen. Klanten zijn van nature erg wispelturig en weten vaak zelf niet goed wat ze willen. Daarom is een ontwikkelmethode die sneller van richting kan veranderen tegenwoordig veel waardevoller dan een log systeem waarbij veel analysewerk op voorhand wordt verricht, om daarna alles te ontwikkelen. Een voorbeeld van zo\u0026rsquo;n klassiek log systeem is het waterval model. Een voorbeeld van zo\u0026rsquo;n modern agile systeem is scrum.\nDe volgende Figuur representeert het Scrum principe in de technische wereld:\n   Het Scrum principe verdeelt de ontwikkeltijd in een aantal iteraties, waarbij een iteratie een vooropgestelde tijd is, meestal 14 of 30 dagen, die een vaste kadans bepaalt waarin teams software ontwikkelen. Elke iteratie gebeurt er hetzelfde: bepalen wat te doen binnen die iteratie, de ontwikkeling ervan, en het vrijgeven van een nieuwe versie van het al dan niet volledig afgewerkt product.\nDe introductie van itererende blokken waar taken van de backlog worden genomen en verwerkt, biedt de mogelijkheid tot veranderen. Tussen elke iteratie in kan er worden bijgestuurd door functionaliteit op de (product) backlog te verwijderen, toe te voegen, of te wijzigen.\n1. De Backlog De backlog is een grote lijst van zaken die moeten worden ontwikkeld voordat de klanten tevreden zijn (een \u0026lsquo;story''). Men begint met één grote product backlog waar op een hoog niveau alle eisen in zijn beschreven. Voor elke sprint van x dagen (30 in de Figuur), beslist het team welke items van deze backlog naar de sprint backlog worden verplaatst: dit zijn de zaken die het team denkt te kunnen verwerken in één sprint.\nEen product backlog bevat stories die nog niet goed geanalyseerd en beschreven zijn, waarvan moeilijk te zeggen valt hoeveel werk dit effectief kost. Wanneer dit in een iteratie terecht komt, wordt dit nauwer bekeken door het team. De betere beschrijving leidt tot een accurate inschatting, en mogelijks zelfs meerdere backlog items.\nHet volgende filmpje verduidelijkt de rol van de backlog in het team:\n  2. Taken Een sprint backlog item wordt typisch door ontwikkelaars nog verder opgesplitst in kleinere taken om het werk beter te kunnen verdelen. Bijvoorbeeld, de mogelijkheid tot inloggen met eID kan bestaan uit (1) authenticatiestappen en het inlezen van een kaart, en (2) het UI gedeelte waar de gebruiker mee interageert. Misschien beschikt al één teamlid over authenticatie kennis, maar nog niemand weet hoe de UI aan te pakken. In dat geval is taak (1) sneller gedaan dan taak (2).\nAls alle taken zijn opgesplitst, worden er inschattingen gemaakt van elke taak, ten opzichte van een referentie taak. Inschattingen zijn relatieve getallen in Fibonacci nummers: 1, 2, 3, 5, 8, \u0026hellip; Hoe moeilijker of groter de taak, hoe vaker teams verkeerde inschattingen maken, en hoe meer impact dit heeft op de planning, vandaar de snel groeiende nummers. De referentie taak heeft een vast nummer in de rij, zoals bijvoorbeeld 2. Merk op dat dit nummer dus niets te maken heeft met een concreet aantal (uren, dagen) werk.\nStel dat een simpel loginscherm reeds werd ontwikkeld. Men schat dan de moeilijkhei van het authenticeren van eID in ten opzichte van het werk aan het loginscherm: zou dat veel minder werk kosten, of meer? Minder werk: 1. Meer werk: veel moeilijker of een beetje? Veel: 5 of meer. Een beetje: 3.\n3. Een iteratie Elke iteratie bestaande uit bijvoobeeld 30 dagen kan een team een bepaald aantal ingeschatte punten verwerken, zoals 30. Men kiest een aantal taken waarvan de som van de inschatting niet dit maximum overschrijdt, en men begint aan de iteratie.\nElke dag is er \u0026rsquo;s morgens een scrum stand-up: een korte, rechtstaande vergadering, waarin iedereen vertelt:\n Wat hij of zij gisteren gedaan heeft Wat hij of zij vandaag gaat doen Met welke problemen hij of zij kampt  Op die manier is onmiddellijk iedereen op de hoogte. Dit noemt men ook wel een scrum meeting, geïnspireerd op de Rugby scrum. Als men merkt dat collega\u0026rsquo;s problemen hebben kan er dan beslist worden om taken weg te laten, toe te voegen, enzovoort.\nWerk visualiseren Een van de belangrijkste redenen om voor een agile methodologie te kiezen als Scrum, is de mogelijkheid tot het visualiseren van werk. Een team van 6 mensen kan daardoor ten allen tijden in één oogopslag zien aan welke taken wordt gewerkt, welke taken/stories in de iteratie zijn opgenomen, en waar het schoentje knelt (bron):\n  Het Scrumbord  Elke story wordt een \u0026lsquo;swimlane\u0026rsquo; toegewezen: een horizontale band, die wordt opgedeeld in een aantal kolommen. Wanneer alle taken van één story van links naar rechts zijn verhuisd, weet het team dat die bepaalde functionaliteit (de story) klaar is voor de eindgebruikers. De taken kunnen worden gecategoriseerd met behulp van kleurcodes (technische opzet, database werk, UI werk, scherm x, y, \u0026hellip;) De kolommen zelf variëren van team tot team. Een voorbeeld:\n (Task) Todo Doing (in progress in bovenstaande Figuur) To Review/To Test/Done  Een taak die van Doing naar Done wordt verschoven is daarom niet volledig afgewerkt. Het kan zijn dat de ontwikkeling af is, maar dit nog moet worden nagekeken door een technische collega (to review), of worden getest door de customer proxy (to test), of worden uitgerold naar een interne test- of acceptatieomgeving (to deploy).\nIn het volgende filmpje komen verschillende implementaties van persoonlijke scrumborden aan bod, om je een idee te geven van de aanpasbaarheid van zulke borden:\n  Hier wordt het woord kanban gebruikt om aan te geven dat werk wordt gevisualiseerd - maar niet noodzakelijk een deel is van agile softwareontwikkeling of van scrum. Zoals je kan zien is het dus ook een effectieve manier om voor jezelf TODO/DOING/DONE items (school taken, hobby\u0026rsquo;s, \u0026hellip;) op te hangen en dus visueel te maken.\nB. Teams managen: Rolverdelingen Werk verdelen en managen is niet het enige sterkte punt van Scrum. Een efficiënt team opbouwen dat in staat is om verschillende rollen op te nemen is nog een van die punten. Om bovenstaande stories en taken als onderdeel daarvan zo goed mogelijk te kunnen afwerken, dient het werk verdeeld te worden. Hieronder volgt een kort overzicht van de vaakst voorkomende rollen.\nDe Product Owner Een Scrum team is sterk klant-georiënteerd, waarbij stories hoofdzakelijk het gevolv zijn van de vraag van de klant. Ook welke stories in welke iteratie worden opgenomen is het gevolg van de wil van de klant. In de praktijk heeft de klant, een ander bedrijf dus, nauwelijks tijd om het ontwikkelproces op de voet op te volgen.\nDaarom dat de product owner (PO) die belangrijke taak van de klant overneemt. Een Product Owner is een domein expert van het ontwikkelbedrijf die het overzicht bewaart: hij of zij weet welke stories nog moeten volgen, kan wijzigingen laten doorvoeren, en kent het product vanbinnen en vanbuiten. De PO overlegt vaak met de klant zelf en vertegenwoordigt de belangen van de klant bij het ontwikkelbedrijf.\nDe Customer Proxy Stories zijn niet meer dan kleine briefjes waar in een paar zinnen staat beschreven welke grote blokken functionaliteit de klant verwacht. Voordat dit kan worden opgesplitst in deeltaken dient er een grondige analyse uitgevoerd te worden. Dit gebeurt door de customer proxy, vaak ook gewoon analist genoemd.\nDe customer proxy is, zoals het woord zegt, een vervanger voor de klant, die expert is in bepaalde deeldomeinen. De Product Owner bewaart het overzicht op een hoog niveau, van het héle product, en de Customer Proxy is expert in bepaalde deeldomeinen. Ontwikkelaars en proxies discussiëren en beslissen vaak samen de werking van bepaalde delen van het product, waarbij de proxy de belangen van de klant hierin verdedigt. Er zijn typisch meerdere proxies aanwezig in één team, terwijl er maar één product owner is.\nDe Ontwikkelaar Stories worden opgesplitst in taken door de proxy en ontwikkelaar, die de functionele en technische gebundelde kennis gebruiken om problemen op te delen in kleinere, en makkelijker verwerkbare, deelproblemen. De ontwikkelaar is verantwoordelijk voor de implementatie van taken, en kan daardoor taken van todo naar doing en done verhuizen op het scrumbord.\nDe Team leider Ontwikkelen en analyseren loopt nooit van een leien dakje. Een leider zorgt er voor dat het team zo weinig mogelijk last heeft van eender welke vorm van afleiding. Dat betekent zowel te veel druk van de klant als mogelijke administratieve taken die het bedrijf eist van elke werknemer. Een goede team leider is een onzichtbare die er voor zorgt dat iedereen zijn werk kan doen.\nEen tweede taak van de team leider is het opvolgen van vooruitgang van de sprint. Het zou kunnen dat ingeschatte stories meer werk kosten dan initiëel gepland, of dat er een gaatje is om extra werk op te nemen. Dit wordt gevisualiseerd door middel van een \u0026lsquo;burndown chart\u0026rsquo;, een grafiek die het aantal nog te behandelen taken afbeeldt op de resterende tijd in dagen of uren (bron):\n  Een voorbeeld burndown chart  Pieken boven de groene ideaallijn betekent onverwacht extra werk die niet werd ingepland, waarbij de team leider mogelijk moet ingrijpen. Dalingen onder de groene lijn betekent vlot werk met mogelijkheid tot iets extra buiten de sprint. De team leider overlegt vaak met de Product Owner om de verwachtingen zo goed mogelijk bij de ideaallijn gealigneerd te krijgen.\nTrends in burndown charts evalueren is een belangrijke vaardigheid voor elk lid van het team. Iedereen kan in één oogopslag onmiddellijk zien of het team meer werk heeft gedaan dan initieel ingepland, nog op schema ligt, of erg achter hinkt. Pieken en dalingen in de grafiek zijn duidelijke tekenen van onder- of overschattingen van de story\u0026rsquo;s. In bovenstaande grafiek krijgt het team bijvoorbeeld na dag 4 (X-as) een zware dobber te verwerken dat meer tijd kost dan eerst gedacht, die pas na dag 9 wordt opgelost. Tussen dag 11 en 15 verloopt alles op cruise snelheid - het gaat zelfs lichtjes beter dan verwacht. De grafiek \u0026lsquo;remaining effort\u0026rsquo; is de belangrijkste (bron).\n  Een tweede voorbeeld burndown chart  Het effect is erg uitgesproken op de tweede grafiek. Op dag 3 valt het team volledig stil (de oorzaak is natuurlijk niet af te lezen, dit kan zowel liggen aan technische problemen als aan bijvoorbeeld ziekte van een aantal programmeurs), wat de scherpe piek verklaart. De rest van de iteratie zwoegt het team om het verloren werk in te halen, wat pas na dag 10 uiteindelijk bijna lukt.\nDeze informatie is erg belangrijk omdat het kan worden gebruikt om toekomstige sprints in te plannen. Grafieken worden ge-extrapoleerd om een betere inschatting te kunnen maken van het toekomstige werk. Een consistent goed presterend team - de remaining effort lijn ligt onder de remaining time - kan in de toekomst bijvoorbeeld meer werk aan binnen dezelfde iteratie. Het is dan aan de team leider om dit naargelang in te plannen.\nLees meer over de burndown chart via het extra leermateriaal.\nLabo oefeningen Opgave 1 Een oefening in teamspirit en problem solving: The Marshmellow Challenge. Vorm groepen van 3 tot 4 mensen. Elke groep krijgt exact 18 minuten om de challenge tot een goed einde te brengen.\nVoor academiejaar 2019 - 2020, gezien het afstandsonderwijs, vervalt de fysieke vorm van deze opgave. Bestudeer in de plaats daarvan het onderstaande filmpje van de auteur van The Challenge. Denk ondertussen na over de volgende thema\u0026rsquo;s:\n Hoe werken team dynamics? Wie zou je welke verantwoordelijkheden geven, moest je zelf The Challenge ondernemen? Waarom? Wat houdt een team tegen om een hogere toren te bouwen dan een ander team?    Opgave 2 Voor academiejaar 2019 - 2020 vervalt deze opgave in zijn geheel.\nWerk in teams van 5 mensen: 1 product owner, 1 teamleider, 1 customer proxy, 2 ontwikkelaars. Er zijn twee sprints van telkens 30 minuten voorzien, die jullie kunnen inplannen naar eigen goeddunken. De docent fungeert als klant en zal jullie meedelen welk product dient ontwikkeld te worden. Denk aan de volgende stappen om het ontwikkelen tot een goed einde te brengen:\n Verzin stories gebaseerd op de vraag van de klant. Schat stories in en verdeel ze in iteraties. Knip stories op in taken, die op post-its op het scrumbord verschijnen. Werk taak per taak af. Houd de totale verlopen tijd per story bij om een ruwe burndown chart te kunnen schetsen. Dit helpt jullie bij de planning van de tweede iteratie.  Denk aan de juiste taken voor de juiste rollen!\nDenkvragen  Wat is het voordeel van taken of stories relatief ten opzichte van een referentiestory in te schatten, in plaats van een hoeveelheid in tijd zoals dagen of uren te gebruiken? Wat is het verschil in taak tussen de Product Owner en de Customer Proxy? Hoe lang moet een ideale iteratie volgens jou zijn, in dagen? Beargumenteer. Waarvoor kan een burndown chart gebruikt worden? Bedenk minstens drie verschillende mogelijkheden en beargumenteer.  Extra Leermateriaal  Ken Schwaber, Jeff Sutherland: What is Scrum? Dusan Kocurek: Understanding the Scrum Burndown Chart Martin Fowler: Agile Software Guide  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/extra/sessy-extending/",
	"title": "Extending the SESsy WebApp",
	"tags": [],
	"description": "",
	"content": "SESsy Library Uitbreiden Lees eerst de installatieinstructies en basics over de SESsy Library app.\nMet de SESsy Library WebApp kunnen verstokte lezers (en mensen die boeken nooit terugbrengen) de database van de lokale bibliotheek raadplegen, en eventueel boeken uitlenen. Het is een simpele webapplicatie met een embedded server die standaard op poort 8080 draait, met een minimale front-end interface:\n   De codebase bevat echter nog heel wat lijntjes TODO commentaar die door de luie ontwikkelaars nooit zijn geïmplementeerd. Het is aan jullie om de applicatie verder af te werken, en deze tekortkomingen handig weg te werken. Uiteraard weten jullie ondertussen dat de twee hoekstenen van goede softwareontwikkeling test-driven development en design patterns zijn. Pas deze concepten ook bij het uitbreiden van deze applicatie toe.\nIntelliJ biedt hiervoor het \u0026ldquo;TODO window\u0026rdquo; aan (CMD-6 of CTRL-6). Elke regel commentaar die begint met // TODO doe dit of dat verschijnt automatisch in dit venster.\nOpgave 1 Neem een kijkje in de klasse BookLendService. De uitleen- en teruggeeffuncties zijn sterk vereenvoudigd:\npublic void lend(Book book, User user) { book.borrow(); } Waarbij de borrowed flag op true of false wordt gezet. Er ontbreekt hier nog heel wat logica:\n Mag de gebruiker die binnen komt als parameter dit boek wel uitlenen? In het geval van teruggeven, mag dat? Als die user null is - dus niet ingelogd - wat gebeurt er dan? Moeten we valideren of het book object correct is - zijnde, is dat ISBN nummer wel aanwezig in onze database? Ik kan niet aan de lokale bib vragen een boek uit te lenen als het er nooit is geweest. Ik kan ook geen boek \u0026lsquo;terugbrengen\u0026rsquo; om het cadeau te geven. Het veranderen van de staat van het object wordt momenteel niet gepersisteerd. Dat betekent dat de volgende keer als we zoeken naar boeken, plots het boek terug beschikbaar is. De BooksRepository interface moet dus worden aangesproken, maar die is momenteel nog niet geïnjecteerd.  Voorzie ook een BookLendServiceTests klasse in de src/test/java map, in de juiste package subfolder. Denk na over het gebruik van unit- of integratietesten. Het spreekt voor zich dat je je implementatie best ook eens manueel, volledig geïntegreerd, test door de applicatie op te starten.\nOpgave 2 De unit testen voor de klasse BorrowBooksResource zijn niet allemaal zuivere unit testen: sommigen leunen ook op de implementatie van BookLendService (wat het eerder integratietestem maakt). De kans is groot dat enkele testen kapot zijn door de implementatie van opgave 1. De TODO in deze klasse spreekt voor zich: gebruik Dependency Injection om de service te injecteren.\nMockito maakt het erg eenvoudig om dynamisch implementaties van interfaces te genereren, maar onze service is geen interface. Gewone klassen testen is minder evident voor het framework. Voorzie daarom een interface bovenop de standaard implementatie die de methodes lend() en bringBack() bevat, zodat we gedrag kunnen beschrijven in onze unit testen voor de borrow books resource.\nOpgave 3 De gebruikersgroep \u0026lsquo;slechte uitleners\u0026rsquo; zijn echt, echt slecht. Ze luisteren nooit, en zorgen er nog ooit voor dat onze bibliotheek failliet gaat. We willen bij deze strengere maatregelen hanteren wat betreft het uitlenen van boeken:\n Slechte Uitleners mogen nooit meer dan 2 boeken tegelijkertijd uitlenen. Dit is momenteel onmogelijk om na te gaan, want een boek bevat slechts een boolean. Dat wil zeggen dat we dan ook onze trouwe klanten, de goede uitleners, straffen. We kunnen een extra veld introduceren of de boolean veranderen van data type, zodat we weten elk boek wordt bijgehouden door welke gebruiker. Anoniempjes, dus de niet-ingelogde gebruikers, willen we een beperkte view op de database aanbieden. Reeds uitgeleende boeken mogen niet meer worden getoond in de resultaten van de zoek pagina. Welke klasse(n) dien je daarvoor te wijzigen? Welke edge cases (lees: testgevallen) kan je daarvoor verzinnen?    Dit uitgeleend boek mag niet meer verschijnen voor anonieme gebruikers.  Vergeet niet dat wijzigingen in de Book datastructuur grote gevolgen hebben voor de rest van de applicatie! De database, aangedreven door BooksRepository, zal ook moeten wijzigen. Een String in Java is een VARCHAR in SQL.\nDe front-end Javascript code gaat steeds uit van een borrowed flag die wordt gecontroleerd om de gele \u0026ldquo;uitgeleend\u0026rdquo; waarschuwing weer te geven. Je kan indien gewenst deze code in Zoeken.vue wijzigen, of de boolean laten staan en aan- of uitzetten naargelang de waarde van het nieuwe String veld. Bijvoorbeeld:\npublic void setBorrowedBy(String user) { this.borrowedBy = user; this.borrowed = user != null ? true : false; // of lege String checken } Ik zeg altijd:\n ./gradlew test is uw vriend!\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/extra/software/",
	"title": "Gebruikte Software",
	"tags": [],
	"description": "",
	"content": "Voor deze cursus werken we met Java en met Git. Dat betekent dat JDK 15.0.2 (en de Gradle build tool, v6.7) en een Git client de enige vereisten zijn.\nOnderstaande lijst kan helpen bij het installeren en configureren van zulke tools:\nCommandline Tools  git-scm gradle  Het is onze intentie om jullie kennis van Linux commando\u0026rsquo;s, opgedaan in het vak Besturingssystemen en C, hier ook van pas te laten komen. Daarom is het aangeraden om dezelfde virtuele machine te gebruiken voor BESC en voor SES. Indien dit voor jou niet lukt, vanwege performantieproblemen of andere, kan je toch nog op Windows met unix-like commandos werken. Daarvoor raden we één van de volgende toolchain aan:\n cmder, Portable console Emulator for Windows MinGW, minimalist GNU for Windows Cygwin  Let op, bovenstaande tools mixen kan grote negatieve gevolgen hebben, iedere GNU flavor werkt op een andere manier en ze bëinvloeden allemaal je %PATH% systeen variabele (Unix: $PATH)\nSoftware Development Tools Installatieinstructies JDK 1. Install JDK Via:\n https://jdk.java.net/archive/ zonder in te loggen, of https://www.oracle.com/java/technologies/downloads/archive/ (Oracle account vereist).  De exacte JDK versie is erg belangrijk. Installeer versie 15.0.2.\n 2. Set JAVA_HOME Windows gebruikers: volg De HowToDoInJava Installing Java on 64 bit Windows guide om jullie %PATH% en %JAVA_HOME% omgevingsvariabelen correct op te zetten.\nAls alles gelukt is, kan je in een opdrachtprompt java -version typen en krijg je als resultaat de geïnstalleerde Java versie.\nUnix gebruikers: Editeer jullie ~/.bash_profile , ~/.bashrc of ~/.zshrc, afhankelijk van de gebruikte cmdline $SHELL, en voeg de $JAVA_HOME variabele toe op de volgende manier (pas het pad aan):\nexport JAVA_HOME=\u0026#34;/dir/to/jdk/home\u0026#34; export PATH=\u0026#34;$JAVA_HOME/bin:$PATH\u0026#34; Installatieinstructies Gradle NIET apart installeren - dit wordt automatisch gedownload bij het bootstrappen van een Gradle project.\nInstallatieinstructies IntelliJ  IntelliJ IDEA Java Development Kit 15.x of later  De IntelliJ community edition is voldoende. Studenten krijgen een gratis licentie op alle JetBrains producten.\nStudenten gebrand op de \u0026ldquo;Ultimate Edition\u0026rdquo; kunnen hun registreren op de website met het @student.uhasselt.be e-mail adres zodat het bedrijf herkent dat je studeert aan een Universitaire Instelling. Dan is ook die versie gratis te downloaden.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/extra/github-classroom/",
	"title": "Oefenzittingen: Github Clasroom",
	"tags": [],
	"description": "",
	"content": "Onderstaande Github Classroom repositories zijn telkens Gradle projecten. Bewkaam jezelf eerst in de basis van Gradle als build tool.\nJe mag kiezen om oefeningen ofwel in Java ofwel in Kotlin uit te voeren, maar submissies dienen Gradle projecten te zijn!\nLabo oefeningen TDD 2ba: vrijdag 04/03/2022\n TDD opgave 1: https://classroom.github.com/a/kLLq7-Xx TDD opgave 2: https://classroom.github.com/a/K0oEWxa1 TDD opgave 4, 5: zelfde als opgave 1  Design Patterns 2ba: vrijdag 31/03/2022\n Facade: https://classroom.github.com/a/kW_nqWIO Dependency Injection: https://classroom.github.com/a/YuIOk837 Singleton: https://classroom.github.com/a/MM3j9szP Decorator: https://classroom.github.com/a/vunlOrb- Factory: https://classroom.github.com/a/jJKB0Qhk  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/extra/sessy/",
	"title": "SESsy Library WebApp",
	"tags": [],
	"description": "",
	"content": "SESsy Library: Een geïntegreerde oefening Download Locatie: op  Github via https://github.com/KULeuven-Diepenbeek/sessylibrary. Zie README.md op de hoofdpagina. SESsy library is:\n A Library Management Simulation WebApp for the \u0026lsquo;SES\u0026rsquo; (Software Engineering Skills) course\n   Een boek uitlenen in de SESsy Library webapp.  Installatie Download via bovenstaande Github link, of met git clone. Dit is een \u0026ldquo;Gradle\u0026rdquo; project, die de build van ons Java ecosysteem verzorgt. Dat wil zeggen dat het Gradle systeem automatisch libraries (jar bestanden) download van een centrale repository, moesten die nodig zijn. Het enige wat jij moet installeren is Java:\nMinimum Vereisten  Java 11 Gradle 5.6.x of hoger  Installeer Gradle en de lokale dependencies door middel van de Gradle wrapper. Voer in de sessylibrary map gradlew.bat (of ./gradlew voor Unix) uit. Dit download automatisch de juiste versie van Gradle.\nHet project builden Command-line: gradlew.bat shadowjar.  Het resultaat is sessylibrary-1.0-SNAPSHOT-all.jar in de build\\libs folder.\nMet IntelliJ: open het project (selecteer de root folder), en klik op \u0026lsquo;build\u0026rsquo;. Alternatief kan je met IntelliJ de gradle.build file openen en de juiste task starten door in de Gutter op het groene start knopje te klikken.\nHet project (de server) opstarten Er zijn verschillende manieren om de gebuilde jar file aan het draaien te brengen:\n Command-line Java: Na het builden van de jar, uitvoeren (in de root folder) met java -jar build\\libs\\sessylibrary-1.0-SNAPSHOT-all.jar server app.yml. Command-line Gradle: (eenvoudiger) ./gradlew serve. Voert bovenstaande commando uit, reeds door ons zo geconfigureerd. IntelliJ: Menu Run -\u0026gt; Run\u0026hellip; Kies voor klasse be.kuleuven.sessylibrary.SessyLibApplication en geef als program arguments (NIET met VM options) \u0026ldquo;server app.yml\u0026rdquo; in. Klik op Apply/Run.  De applicatie staat nu live op http://localhost:8080!\nIndien je \u0026ldquo;port already in use\u0026rdquo; Exceptions krijgt, en je niet in de mogelijkheid bent om poort 8080 vrij te maken, kan je in app.yml kiezen voor een andere HTTP poort. Plak daarom onderstaande stuk in je config file:\n server: rootPath: /api/ applicationConnectors: - type: http port: 9000 (of 8088, of ....) Componenten (Documentatie overgenomen uit de Git repository README.md)\nBackend DropWizard Java RESTful API that integrates Jetty/Jackson/\u0026hellip; functionality in a nice all-in-one package. This means executing the jar automatically bootstraps a webserver, and REST calls can be easily added using javax.ws annotations. See be.kuleuven.sessylibrary.api classes for examples.\nFrontend VueJS Progressive single-page JS framework that calls the above API endpoints and is served from the very same webserver thanks to the dropwizard-assets module.\nThe compiled vuejs webpage should be copied to src/main/resources/assets - index.htm is served at /.\nStudents do not need to edit the frontend part of this application and may consider this as a \u0026lsquo;given\u0026rsquo;.\nBuilding and running the Frontend source:\n npm install in the frontend subdir npm run serve in the frontend subdir  Extra leermateriaal  DropWizard: Getting Started Gradle User Guide VueJS Guide Bootstrap VueJS Components  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/",
	"title": "Software Engineering Skills",
	"tags": [],
	"description": "",
	"content": "Software Engineering Skills Laatste aanpassingen voor academiejaar 2021 - 2022.\nCursus notities Labo noties Software Development: Pre-Requirements  Versie- en issuebeheer Dependency Management:  De Gradle Build Tool Kotlin-specifics)   Test-Driven Development: Unit-, Integration- (1) en E2E (2) niveau TDD In de praktijk  Algoritmen \u0026amp; Data Structuren  Hoorcolleges: zie Toledo Cursusmateriaal Test-Driven Development met algoritmes: Capita Selecta  Design Patterns Een introductie tot Design Patterns.\n Facade ( voorbeeld) (1) Dependency Injection ( voorbeeld) Singleton ( voorbeeld) (2) Decorator ( voorbeeld) Factory ( voorbeeld) (3)  Software Development: Life Cycle Continuous Integration \u0026amp; Deployment Software Management: Skills (1), Scrum (2)  Aanvullende Oefeningen  De \u0026lsquo;SESsy Library\u0026rsquo; WebApp: uitbreiden  Extra informatie  Gebruikte Software: een overzicht De \u0026lsquo;SESsy Library\u0026rsquo; WebApp: installatie \u0026amp; configuratie Gradle build tools  Github Classroom links  Syllabus  Lesgevers: Coördinerend Verantwoordelijke: prof. dr. Kris Aerts - kris.aerts@kuleuven.be Onderwijsassistent: Wouter Groeneveld - wouter.groeneveld@kuleuven.be Kantoor: Technologiecentrum Diepenbeek, Groep ACRO, D.0.35.  Cursusbeschrijving In dit opleidingsonderdeel leer je de nodige skills om een softwareproject op de wereld te brengen volgens de regels van de kunst en met het aandacht voor de courante industriële praktijk. Op microniveau kom je meer te weten over de eigenschappen van algoritmes en datastructuren zodat je zelf de juiste keuze kan maken wanneer je een algoritme moet implementeren. Op macroniveau zorgen design patterns er voor dat je software beter onderhoudbaar wordt en een structuur heeft die herkenbaar is voor experten. Daarnaast gaan we in op de Software Development Life Cycle en het management van zo\u0026rsquo;n softwareproject met aandacht voor de juiste tools.\nVereiste voorkennis Het vak \u0026lsquo;Software Ontwerp in Java\u0026rsquo; (INF1) dient eerst gevolgd te worden. We gaan uit van een basiskennis Java en object-georienteerd programmeren. Werken met commandline en enige kennis van git is een pluspunt.\nDoelstellingen Zie ook Studiegids UHasselt\nDe context en het overzicht worden aangereikt in het hoorcollege.\nBeoordeling en evaluatie  Schriftelijke evaluatie tijdens onderwijsperiode: 50%. Schriftelijk examen: 50%  Een uitgebreide beschrijving is beschikbaar in de gids van het Opleidingsonderdeel. Zie de kalender hieronder voor een kort overzicht rond de evaluatie tijdens de onderwijsperiode.\nMeer leermiddelen Zie elke sectie \u0026lsquo;meer leermateriaal\u0026rsquo; in de labo noties voor materiaal per thema.\nKalender Zie collegeroosters UHasselt.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/ses-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]